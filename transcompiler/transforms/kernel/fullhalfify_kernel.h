#pragma once

#include <vector>
#include <array>
#include <fcntl.h>
#include <string>
#include <iostream>

#include <unicode/data/PropertyObjects.h>
#include <unicode/data/PropertyObjectTable.h>
#include <unicode/core/unicode_set.h>
#include <unicode/utf/utf_compiler.h>
#include <unicode/utf/transchar.h>

#include <kernel/streamutils/deletion.h>
#include <kernel/streamutils/string_insert.h>
#include <kernel/streamutils/pdep_kernel.h>
#include <kernel/pipeline/driver/cpudriver.h>
#include <kernel/pipeline/pipeline_builder.h>
#include <kernel/unicode/UCD_property_kernel.h>
#include <kernel/unicode/utf8_decoder.h>
#include <kernel/unicode/charclasses.h>
#include <kernel/unicode/utf8gen.h>
#include <kernel/basis/s2p_kernel.h>
#include <kernel/basis/p2s_kernel.h>
#include <kernel/core/kernel_builder.h>
#include <kernel/io/source_kernel.h>
#include <kernel/io/stdout_kernel.h>

#include <pablo/codegenstate.h>
#include <pablo/pe_zeroes.h>        // for Zeroes
#include <pablo/bixnum/bixnum.h>

#include <grep/grep_kernel.h>

#include <llvm/Support/CommandLine.h>
#include <llvm/Support/ErrorHandling.h>
#include <llvm/Support/raw_ostream.h>

#include <re/toolchain/toolchain.h>
#include <re/adt/re_name.h>
#include <re/adt/re_re.h>
#include <re/cc/cc_compiler_target.h>
#include <re/cc/cc_compiler.h>
#include <re/cc/cc_kernel.h>


using namespace kernel;
using namespace llvm;
using namespace pablo;

class FullHalfify : public pablo::PabloKernel {
public:
    FullHalfify(KernelBuilder & b, StreamSet * U21, StreamSet * translationBasis, StreamSet * u32Basis)
    : pablo::PabloKernel(b, "FullHalfify",
                        {Binding{"U21", U21}, Binding{"translationBasis", translationBasis}},
                            {Binding{"u32Basis", u32Basis}}) {}
protected:
    void generatePabloMethod() override;
};

void FullHalfify::generatePabloMethod() {
    //  pb is an object used for build Pablo language statements
    pablo::PabloBuilder pb(getEntryScope());

    // Get the input stream sets.
    std::vector<PabloAST *> U21 = getInputStreamSet("U21");

    std::vector<PabloAST *> translationBasis = getInputStreamSet("translationBasis");
    std::vector<PabloAST *> transformed(U21.size());

    Var * outputBasisVar = getOutputStreamVar("u32Basis");

    // For each bit of the input stream
    for (unsigned i = 0; i < U21.size(); i++) {
        // If the translation set covers said bit
        if (i < translationBasis.size()) // XOR the input bit with the transformation bit  
            transformed[i] = pb.createXor(translationBasis[i], U21[i]);
        else transformed[i] = U21[i];

        pb.createAssign(pb.createExtract(outputBasisVar, pb.getInteger(i)), transformed[i]);
    }
}

void doFullHalfTransform(PipelineBuilder & P, StreamSet * Basis, StreamSet * Output);

inline void doFullHalfTransform(const std::unique_ptr<PipelineBuilder> & P, StreamSet * Basis, StreamSet * Output) {
    return doFullHalfTransform(*P.get(), Basis, Output);
}

inline void doFullHalfTransform(const std::unique_ptr<ProgramBuilder> & P, StreamSet * Basis, StreamSet * Output) {
    return doFullHalfTransform(*P.get(), Basis, Output);
}

void doFullHalfTransform(PipelineBuilder & P, StreamSet * Basis, StreamSet * Output) {
    // The codepoint map auto-generated by python script
    const static std::unordered_map<codepoint_t, codepoint_t> explicit_cp_data = {{0xFF01, 0x0021}, {0xFF02, 0x0022}, {0xFF03, 0x0023}, {0xFF04, 0x0024}, {0xFF05, 0x0025}, {0xFF06, 0x0026}, {0xFF07, 0x0027}, {0xFF08, 0x0028}, {0xFF09, 0x0029}, {0xFF0A, 0x002A}, {0xFF0B, 0x002B}, {0xFF0C, 0x002C}, {0xFF0D, 0x002D}, {0xFF0E, 0x002E}, {0xFF0F, 0x002F}, {0xFF10, 0x0030}, {0xFF11, 0x0031}, {0xFF12, 0x0032}, {0xFF13, 0x0033}, {0xFF14, 0x0034}, {0xFF15, 0x0035}, 
{0xFF16, 0x0036}, {0xFF17, 0x0037}, {0xFF18, 0x0038}, {0xFF19, 0x0039}, {0xFF1A, 0x003A}, {0xFF1B, 0x003B}, {0xFF1C, 0x003C}, {0xFF1D, 0x003D}, {0xFF1E, 0x003E}, {0xFF1F, 0x003F}, {0xFF20, 0x0040}, {0xFF21, 0x0041}, {0xFF22, 0x0042}, {0xFF23, 0x0043}, {0xFF24, 0x0044}, {0xFF25, 0x0045}, {0xFF26, 0x0046}, {0xFF27, 0x0047}, {0xFF28, 0x0048}, {0xFF29, 0x0049}, {0xFF2A, 0x004A}, {0xFF2B, 0x004B}, {0xFF2C, 0x004C}, {0xFF2D, 0x004D}, {0xFF2E, 0x004E}, {0xFF2F, 0x004F}, {0xFF30, 0x0050}, {0xFF31, 0x0051}, {0xFF32, 0x0052}, {0xFF33, 0x0053}, {0xFF34, 0x0054}, {0xFF35, 0x0055}, {0xFF36, 0x0056}, {0xFF37, 0x0057}, {0xFF38, 0x0058}, {0xFF39, 0x0059}, {0xFF3A, 0x005A}, {0xFF3B, 0x005B}, {0xFF3C, 0x005C}, {0xFF3D, 0x005D}, {0xFF3E, 0x005E}, {0xFF3F, 0x005F}, {0xFF40, 0x0060}, {0xFF41, 0x0061}, {0xFF42, 0x0062}, {0xFF43, 0x0063}, {0xFF44, 0x0064}, {0xFF45, 0x0065}, {0xFF46, 0x0066}, {0xFF47, 0x0067}, {0xFF48, 0x0068}, {0xFF49, 0x0069}, {0xFF4A, 0x006A}, {0xFF4B, 0x006B}, {0xFF4C, 0x006C}, {0xFF4D, 0x006D}, {0xFF4E, 0x006E}, {0xFF4F, 0x006F}, {0xFF50, 0x0070}, {0xFF51, 0x0071}, {0xFF52, 0x0072}, {0xFF53, 0x0073}, {0xFF54, 0x0074}, {0xFF55, 0x0075}, {0xFF56, 0x0076}, {0xFF57, 0x0077}, {0xFF58, 0x0078}, {0xFF59, 0x0079}, {0xFF5A, 0x007A}, {0xFF5B, 0x007B}, {0xFF5C, 0x007C}, {0xFF5D, 0x007D}, {0x11A8, 0xFFA1}, {0x11A9, 0xFFA2}, {0x11AA, 0xFFA3}, {0x11AB, 0xFFA4}, 
{0x11AC, 0xFFA5}, {0x11AD, 0xFFA6}, {0x11AE, 0xFFA7}, {0x1104, 0xFFA8}, {0x11AF, 0xFFA9}, {0x11B0, 0xFFAA}, {0x11B1, 0xFFAB}, {0x11B2, 0xFFAC}, {0x11B3, 0xFFAD}, {0x11B4, 0xFFAE}, {0x11B5, 0xFFAF}, {0x11B6, 0xFFB0}, {0x11B7, 0xFFB1}, {0x11B8, 0xFFB2}, {0x11B9, 0xFFB4}, {0x1108, 0xFFB3}, {0x11BA, 0xFFB5}, {0x11BB, 0xFFB6}, {0x11BC, 0xFFB7}, {0x11BD, 0xFFB8}, {0x11BE, 0xFFBA}, {0x110D, 0xFFB9}, {0x11BF, 0xFFBB}, {0x11C0, 0xFFBC}, {0x11C1, 0xFFBD}, {0x11C2, 0xFFBE}, {0x1161, 0xFFC2}, {0x1162, 0xFFC3}, {0x1163, 0xFFC4}, {0x1164, 0xFFC5}, {0x1165, 0xFFC6}, {0x1166, 0xFFC7}, {0x1167, 0xFFCA}, {0x1168, 0xFFCB}, {0x1169, 0xFFCC}, {0x116A, 0xFFCD}, {0x116B, 0xFFCE}, {0x116C, 0xFFCF}, {0x116D, 0xFFD2}, {0x116E, 0xFFD3}, {0x116F, 0xFFD4}, {0x1170, 0xFFD5}, {0x1171, 0xFFD6}, {0x1172, 0xFFD7}, {0x1173, 0xFFDA}, {0x1174, 0xFFDB}, {0x1175, 0xFFDC}, {0x30F2, 0xFF66}, {0x30A1, 0xFF67}, {0x30A2, 0xFF71}, {0x30A3, 0xFF68}, {0x30A4, 0xFF72}, {0x30A5, 0xFF69}, {0x30A6, 0xFF73}, {0x30A7, 0xFF6A}, {0x30A8, 0xFF74}, {0x30A9, 0xFF6B}, {0x30AA, 0xFF75}, {0x30AB, 0xFF76}, {0x30AD, 0xFF77}, {0x30AF, 0xFF78}, {0x30B1, 0xFF79}, {0x30B3, 0xFF7A}, {0x30B5, 0xFF7B}, {0x30B7, 0xFF7C}, {0x30B9, 0xFF7D}, {0x30BB, 0xFF7E}, {0x30BD, 0xFF7F}, {0x30BF, 0xFF80}, {0x30C1, 0xFF81}, {0x30C3, 0xFF6F}, {0x30C4, 0xFF82}, {0x30C6, 0xFF83}, {0x30C8, 0xFF84}, {0x30CA, 0xFF85}, {0x30CB, 0xFF86}, 
{0x30CC, 0xFF87}, {0x30CD, 0xFF88}, {0x30CE, 0xFF89}, {0x30CF, 0xFF8A}, {0x30D2, 0xFF8B}, {0x30D5, 0xFF8C}, {0x30D8, 0xFF8D}, {0x30DB, 0xFF8E}, {0x30DE, 0xFF8F}, {0x30DF, 0xFF90}, {0x30E0, 0xFF91}, {0x30E1, 0xFF92}, {0x30E2, 0xFF93}, {0x30E3, 0xFF6C}, {0x30E4, 0xFF94}, {0x30E5, 0xFF6D}, {0x30E6, 0xFF95}, {0x30E7, 0xFF6E}, {0x30E8, 0xFF96}, {0x30E9, 0xFF97}, {0x30EA, 0xFF98}, {0x30EB, 0xFF99}, {0x30EC, 0xFF9A}, {0x30ED, 0xFF9B}, {0x30EF, 0xFF9C}, {0x30F3, 0xFF9D}, {0x309C, 0xFF9F}, {0x3099, 0xFF9E}, {0x309B, 0xFF9E}, {0x30FC, 0xFF70}, {0x30FB, 0xFF65}, {0xFF5F, 0x2985}, {0xFF60, 0x2986 }, {0x3002, 0xFF61}, {0x300C, 0xFF62}, {0x300D, 0xFF63}, {0x3001, 0xFF64}, {0xFFE0, 0x00A2}, {0xFFE1, 0x00A3}, {0xFFE2, 0x00AC}, {0xFFE3, 0x00AF}, {0xFFE4, 0x00A6}, {0xFFE5, 0x00A5}, {0xFFE6, 0x20A9}, {0x2502, 0xFFE8}, {0x2190, 0xFFE9}, {0x2191, 0xFFEA}, {0x2192, 0xFFEB}, {0x2193, 0xFFEC}, {0x25A0, 0xFFED}, {0x25CB, 0xFFEE}};

    unicode::TranslationMap mExplicitCodepointMap = (unicode::TranslationMap) explicit_cp_data;
    unicode::BitTranslationSets translationSet = unicode::ComputeBitTranslationSets(mExplicitCodepointMap);

    // Turn the fullHalf translation set into a vector of character classes
    std::vector<re::CC *> translation_ccs;
    for (auto & b : translationSet) {
        translation_ccs.push_back(re::makeCC(b, &cc::Unicode));
    }

    StreamSet * translationBasis = P.CreateStreamSet(translation_ccs.size());
    P.CreateKernelCall<CharClassesKernel>(translation_ccs, Basis, translationBasis);

    // Perform the logic of the FullHalfify kernel on the codepoiont values.
    P.CreateKernelCall<FullHalfify>(Basis, translationBasis, Output);
}