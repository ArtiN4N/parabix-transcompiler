#pragma once

#include <vector>
#include <array>
#include <fcntl.h>
#include <string>
#include <iostream>

#include <unicode/data/PropertyObjects.h>
#include <unicode/data/PropertyObjectTable.h>
#include <unicode/core/unicode_set.h>
#include <unicode/utf/utf_compiler.h>
#include <unicode/utf/transchar.h>

#include <kernel/streamutils/deletion.h>
#include <kernel/streamutils/string_insert.h>
#include <kernel/streamutils/pdep_kernel.h>
#include <kernel/pipeline/driver/cpudriver.h>
#include <kernel/pipeline/pipeline_builder.h>
#include <kernel/unicode/UCD_property_kernel.h>
#include <kernel/unicode/utf8_decoder.h>
#include <kernel/unicode/charclasses.h>
#include <kernel/unicode/utf8gen.h>
#include <kernel/basis/s2p_kernel.h>
#include <kernel/basis/p2s_kernel.h>
#include <kernel/core/kernel_builder.h>
#include <kernel/io/source_kernel.h>
#include <kernel/io/stdout_kernel.h>

#include <pablo/codegenstate.h>
#include <pablo/pe_zeroes.h>        // for Zeroes
#include <pablo/bixnum/bixnum.h>

#include <grep/grep_kernel.h>

#include <llvm/Support/CommandLine.h>
#include <llvm/Support/ErrorHandling.h>
#include <llvm/Support/raw_ostream.h>

#include <re/toolchain/toolchain.h>
#include <re/adt/re_name.h>
#include <re/adt/re_re.h>
#include <re/cc/cc_compiler_target.h>
#include <re/cc/cc_compiler.h>
#include <re/cc/cc_kernel.h>


using namespace kernel;
using namespace llvm;
using namespace pablo;

class HalfFullify : public pablo::PabloKernel {
public:
    HalfFullify(KernelBuilder & b, StreamSet * U21, StreamSet * translationBasis, StreamSet * u32Basis)
    : pablo::PabloKernel(b, "HalfFullify",
                        {Binding{"U21", U21}, Binding{"translationBasis", translationBasis}},
                            {Binding{"u32Basis", u32Basis}}) {}
protected:
    void generatePabloMethod() override;
};

void HalfFullify::generatePabloMethod() {
    //  pb is an object used for build Pablo language statements
    pablo::PabloBuilder pb(getEntryScope());

    // Get the input stream sets.
    std::vector<PabloAST *> U21 = getInputStreamSet("U21");

    std::vector<PabloAST *> translationBasis = getInputStreamSet("translationBasis");
    std::vector<PabloAST *> transformed(U21.size());

    Var * outputBasisVar = getOutputStreamVar("u32Basis");

    // For each bit of the input stream
    for (unsigned i = 0; i < U21.size(); i++) {
        // If the translation set covers said bit
        if (i < translationBasis.size()) // XOR the input bit with the transformation bit  
            transformed[i] = pb.createXor(translationBasis[i], U21[i]);
        else transformed[i] = U21[i];

        pb.createAssign(pb.createExtract(outputBasisVar, pb.getInteger(i)), transformed[i]);
    }
}

void doHalfFullTransform(PipelineBuilder & P, StreamSet * Basis, StreamSet * Output);

inline void doHalfFullTransform(const std::unique_ptr<PipelineBuilder> & P, StreamSet * Basis, StreamSet * Output) {
    return doHalfFullTransform(*P.get(), BixData, Basis, Output);
}

inline void doHalfFullTransform(const std::unique_ptr<ProgramBuilder> & P, StreamSet * Basis, StreamSet * Output) {
    return doHalfFullTransform(*P.get(), BixData, Basis, Output);
}

void doHalfFullTransform(PipelineBuilder & P, StreamSet * Basis, StreamSet * Output) {
    // The codepoint map auto-generated by python script
    const static std::unordered_map<codepoint_t, codepoint_t> explicit_cp_data = {{0x0021, 0xFF01}, {0x0022, 0xFF02}, {0x0023, 0xFF03}, {0x0024, 0xFF04}, {0x0025, 0xFF05}, {0x0026, 0xFF06}, {0x0027, 0xFF07}, {0x0028, 0xFF08}, {0x0029, 0xFF09}, {0x002A, 0xFF0A}, {0x002B, 0xFF0B}, {0x002C, 0xFF0C}, {0x002D, 0xFF0D}, {0x002E, 0xFF0E}, {0x002F, 0xFF0F}, {0x0030, 0xFF10}, {0x0031, 0xFF11}, {0x0032, 0xFF12}, {0x0033, 0xFF13}, {0x0034, 0xFF14}, {0x0035, 0xFF15}, 
{0x0036, 0xFF16}, {0x0037, 0xFF17}, {0x0038, 0xFF18}, {0x0039, 0xFF19}, {0x003A, 0xFF1A}, {0x003B, 0xFF1B}, {0x003C, 0xFF1C}, {0x003D, 0xFF1D}, {0x003E, 0xFF1E}, {0x003F, 0xFF1F}, {0x0040, 0xFF20}, {0x0041, 0xFF21}, {0x0042, 0xFF22}, {0x0043, 0xFF23}, {0x0044, 0xFF24}, {0x0045, 0xFF25}, {0x0046, 0xFF26}, {0x0047, 0xFF27}, {0x0048, 0xFF28}, {0x0049, 0xFF29}, {0x004A, 0xFF2A}, {0x004B, 0xFF2B}, {0x004C, 0xFF2C}, {0x004D, 0xFF2D}, {0x004E, 0xFF2E}, {0x004F, 0xFF2F}, {0x0050, 0xFF30}, {0x0051, 0xFF31}, {0x0052, 0xFF32}, {0x0053, 0xFF33}, {0x0054, 0xFF34}, {0x0055, 0xFF35}, {0x0056, 0xFF36}, {0x0057, 0xFF37}, {0x0058, 0xFF38}, {0x0059, 0xFF39}, {0x005A, 0xFF3A}, {0x005B, 0xFF3B}, {0x005C, 0xFF3C}, {0x005D, 0xFF3D}, {0x005E, 0xFF3E}, {0x005F, 0xFF3F}, {0x0060, 0xFF40}, {0x0061, 0xFF41}, {0x0062, 0xFF42}, {0x0063, 0xFF43}, {0x0064, 0xFF44}, {0x0065, 0xFF45}, {0x0066, 0xFF46}, {0x0067, 0xFF47}, {0x0068, 0xFF48}, {0x0069, 0xFF49}, {0x006A, 0xFF4A}, {0x006B, 0xFF4B}, {0x006C, 0xFF4C}, {0x006D, 0xFF4D}, {0x006E, 0xFF4E}, {0x006F, 0xFF4F}, {0x0070, 0xFF50}, {0x0071, 0xFF51}, {0x0072, 0xFF52}, {0x0073, 0xFF53}, {0x0074, 0xFF54}, {0x0075, 0xFF55}, {0x0076, 0xFF56}, {0x0077, 0xFF57}, {0x0078, 0xFF58}, {0x0079, 0xFF59}, {0x007A, 0xFF5A}, {0x007B, 0xFF5B}, {0x007C, 0xFF5C}, {0x007D, 0xFF5D}, {0xFFA1, 0x11A8}, {0xFFA2, 0x11A9}, {0xFFA3, 0x11AA}, {0xFFA4, 0x11AB}, 
{0xFFA5, 0x11AC}, {0xFFA6, 0x11AD}, {0xFFA7, 0x11AE}, {0xFFA8, 0x1104}, {0xFFA9, 0x11AF}, {0xFFAA, 0x11B0}, {0xFFAB, 0x11B1}, {0xFFAC, 0x11B2}, {0xFFAD, 0x11B3}, {0xFFAE, 0x11B4}, {0xFFAF, 0x11B5}, {0xFFB0, 0x11B6}, {0xFFB1, 0x11B7}, {0xFFB2, 0x11B8}, {0xFFB4, 0x11B9}, {0xFFB3, 0x1108}, {0xFFB5, 0x11BA}, {0xFFB6, 0x11BB}, {0xFFB7, 0x11BC}, {0xFFB8, 0x11BD}, {0xFFBA, 0x11BE}, {0xFFB9, 0x110D}, {0xFFBB, 0x11BF}, {0xFFBC, 0x11C0}, {0xFFBD, 0x11C1}, {0xFFBE, 0x11C2}, {0xFFC2, 0x1161}, {0xFFC3, 0x1162}, {0xFFC4, 0x1163}, {0xFFC5, 0x1164}, {0xFFC6, 0x1165}, {0xFFC7, 0x1166}, {0xFFCA, 0x1167}, {0xFFCB, 0x1168}, {0xFFCC, 0x1169}, {0xFFCD, 0x116A}, {0xFFCE, 0x116B}, {0xFFCF, 0x116C}, {0xFFD2, 0x116D}, {0xFFD3, 0x116E}, {0xFFD4, 0x116F}, {0xFFD5, 0x1170}, {0xFFD6, 0x1171}, {0xFFD7, 0x1172}, {0xFFDA, 0x1173}, {0xFFDB, 0x1174}, {0xFFDC, 0x1175}, {0xFF66, 0x30F2}, {0xFF67, 0x30A1}, {0xFF71, 0x30A2}, {0xFF68, 0x30A3}, {0xFF72, 0x30A4}, {0xFF69, 0x30A5}, {0xFF73, 0x30A6}, {0xFF6A, 0x30A7}, {0xFF74, 0x30A8}, {0xFF6B, 0x30A9}, {0xFF75, 0x30AA}, {0xFF76, 0x30AB}, {0xFF77, 0x30AD}, {0xFF78, 0x30AF}, {0xFF79, 0x30B1}, {0xFF7A, 0x30B3}, {0xFF7B, 0x30B5}, {0xFF7C, 0x30B7}, {0xFF7D, 0x30B9}, {0xFF7E, 0x30BB}, {0xFF7F, 0x30BD}, {0xFF80, 0x30BF}, {0xFF81, 0x30C1}, {0xFF6F, 0x30C3}, {0xFF82, 0x30C4}, {0xFF83, 0x30C6}, {0xFF84, 0x30C8}, {0xFF85, 0x30CA}, {0xFF86, 0x30CB}, 
{0xFF87, 0x30CC}, {0xFF88, 0x30CD}, {0xFF89, 0x30CE}, {0xFF8A, 0x30CF}, {0xFF8B, 0x30D2}, {0xFF8C, 0x30D5}, {0xFF8D, 0x30D8}, {0xFF8E, 0x30DB}, {0xFF8F, 0x30DE}, {0xFF90, 0x30DF}, {0xFF91, 0x30E0}, {0xFF92, 0x30E1}, {0xFF93, 0x30E2}, {0xFF6C, 0x30E3}, {0xFF94, 0x30E4}, {0xFF6D, 0x30E5}, {0xFF95, 0x30E6}, {0xFF6E, 0x30E7}, {0xFF96, 0x30E8}, {0xFF97, 0x30E9}, {0xFF98, 0x30EA}, {0xFF99, 0x30EB}, {0xFF9A, 0x30EC}, {0xFF9B, 0x30ED}, {0xFF9C, 0x30EF}, {0xFF9D, 0x30F3}, {0xFF9F, 0x309C}, {0xFF9E, 0x3099}, {0xFF9E, 0x309B}, {0xFF70, 0x30FC}, {0xFF65, 0x30FB}, {0x2985, 0xFF5F}, {0x2986 , 0xFF60}, {0xFF61, 0x3002}, {0xFF62, 0x300C}, {0xFF63, 0x300D}, {0xFF64, 0x3001}, {0x00A2, 0xFFE0}, {0x00A3, 0xFFE1}, {0x00AC, 0xFFE2}, {0x00AF, 0xFFE3}, {0x00A6, 0xFFE4}, {0x00A5, 0xFFE5}, {0x20A9, 0xFFE6}, {0xFFE8, 0x2502}, {0xFFE9, 0x2190}, {0xFFEA, 0x2191}, {0xFFEB, 0x2192}, {0xFFEC, 0x2193}, {0xFFED, 0x25A0}, {0xFFEE, 0x25CB}};

    unicode::TranslationMap mExplicitCodepointMap = (unicode::TranslationMap) explicit_cp_data;
    unicode::BitTranslationSets translationSet = unicode::ComputeBitTranslationSets(mExplicitCodepointMap);

    // Turn the fullHalf translation set into a vector of character classes
    std::vector<re::CC *> translation_ccs;
    for (auto & b : translationSet) {
        translation_ccs.push_back(re::makeCC(b, &cc::Unicode));
    }

    StreamSet * translationBasis = P.CreateStreamSet(translation_ccs.size());
    P.CreateKernelCall<CharClassesKernel>(translation_ccs, Basis, translationBasis);

    // Perform the logic of the FullHalfify kernel on the codepoiont values.
    P.CreateKernelCall<FullHalfify>(Basis, translationBasis, Output);
}