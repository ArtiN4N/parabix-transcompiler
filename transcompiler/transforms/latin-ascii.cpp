#include <vector>
#include <fcntl.h>
#include <string>
#include <iostream>

#include <unicode/data/PropertyObjects.h>
#include <unicode/data/PropertyObjectTable.h>
#include <unicode/core/unicode_set.h>
#include <unicode/utf/utf_compiler.h>
#include <unicode/utf/transchar.h>

#include <kernel/streamutils/deletion.h>
#include <kernel/pipeline/driver/cpudriver.h>
#include <kernel/pipeline/pipeline_builder.h>
#include <kernel/unicode/UCD_property_kernel.h>
#include <kernel/unicode/utf8_decoder.h>
#include <kernel/unicode/charclasses.h>
#include <kernel/unicode/utf8gen.h>
#include <kernel/basis/s2p_kernel.h>
#include <kernel/basis/p2s_kernel.h>
#include <kernel/core/kernel_builder.h>
#include <kernel/io/source_kernel.h>
#include <kernel/io/stdout_kernel.h>

#include <pablo/codegenstate.h>

#include <grep/grep_kernel.h>

#include <llvm/Support/CommandLine.h>
#include <llvm/Support/ErrorHandling.h>
#include <llvm/Support/raw_ostream.h>

#include <re/toolchain/toolchain.h>
#include <re/adt/re_name.h>
#include <re/adt/re_re.h>
#include <re/cc/cc_compiler_target.h>
#include <re/cc/cc_compiler.h>
#include <re/cc/cc_kernel.h>


#define SHOW_STREAM(name) if (codegen::EnableIllustrator) P->captureBitstream(#name, name)
#define SHOW_BIXNUM(name) if (codegen::EnableIllustrator) P->captureBixNum(#name, name)
#define SHOW_BYTES(name) if (codegen::EnableIllustrator) P->captureByteData(#name, name)

using namespace kernel;
using namespace llvm;
using namespace pablo;

//  These declarations are for command line processing.
//  See the LLVM CommandLine 2.0 Library Manual https://llvm.org/docs/CommandLine.html
static cl::OptionCategory FullHalfOptions("fullHalf Options", "fullHalf control options.");
static cl::opt<std::string> inputFile(cl::Positional, cl::desc("<input file>"), cl::Required, cl::cat(FullHalfOptions));

class FullHalfify : public pablo::PabloKernel {
public:
    FullHalfify(KernelBuilder & b, StreamSet * U21, StreamSet * translationBasis, StreamSet * u32Basis)
    : pablo::PabloKernel(b, "FullHalfify",
                        {Binding{"U21", U21}, Binding{"translationBasis", translationBasis}},
                            {Binding{"u32Basis", u32Basis}}) {}
protected:
    void generatePabloMethod() override;
};

void FullHalfify::generatePabloMethod() {
    //  pb is an object used for build Pablo language statements
    pablo::PabloBuilder pb(getEntryScope());

    // Get the input stream sets.
    std::vector<PabloAST *> U21 = getInputStreamSet("U21");

    std::vector<PabloAST *> translationBasis = getInputStreamSet("translationBasis");
    std::vector<PabloAST *> transformed(U21.size());

    Var * outputBasisVar = getOutputStreamVar("u32Basis");

    // For each bit of the input stream
    for (unsigned i = 0; i < U21.size(); i++) {
        // If the translation set covers said bit
        if (i < translationBasis.size()) // XOR the input bit with the transformation bit  
            transformed[i] = pb.createXor(translationBasis[i], U21[i]);
        else transformed[i] = U21[i];

        pb.createAssign(pb.createExtract(outputBasisVar, pb.getInteger(i)), transformed[i]);
    }
}


typedef void (*ToFullHalfFunctionType)(uint32_t fd);

ToFullHalfFunctionType generatePipeline(CPUDriver & pxDriver) {
    // A Parabix program is build as a set of kernel calls called a pipeline.
    // A pipeline is construction using a Parabix driver object.
    auto & b = pxDriver.getBuilder();
    auto P = pxDriver.makePipeline({Binding{b.getInt32Ty(), "inputFileDecriptor"}}, {});

    //  The program will use a file descriptor as an input.
    Scalar * fileDescriptor = P->getInputScalar("inputFileDecriptor");
    StreamSet * ByteStream = P->CreateStreamSet(1, 8);

    //  ReadSourceKernel is a Parabix Kernel that produces a stream of bytes
    //  from a file descriptor.
    P->CreateKernelCall<ReadSourceKernel>(fileDescriptor, ByteStream);
    SHOW_BYTES(ByteStream);

    // Get the basis bits
    StreamSet * BasisBits = P->CreateStreamSet(8, 1);
    P->CreateKernelCall<S2PKernel>(ByteStream, BasisBits);
    SHOW_BIXNUM(BasisBits);

    // Convert into codepoints
    StreamSet * u8index = P->CreateStreamSet(1, 1);
    P->CreateKernelCall<UTF8_index>(BasisBits, u8index);
    SHOW_STREAM(u8index);

    StreamSet * U21_u8indexed = P->CreateStreamSet(21, 1);
    P->CreateKernelCall<UTF8_Decoder>(BasisBits, U21_u8indexed);

    StreamSet * U21 = P->CreateStreamSet(21, 1);
    FilterByMask(P, u8index, U21_u8indexed, U21);
    SHOW_BIXNUM(U21);

    // The possible input codes for latin ascii
    std::vector<codepoint_t> latinasciicodes = {0x00C6,0x00D0,0x00D8,0x00DE,0x00DF,0x00E6,0x00F0,0x00F8,0x00FE,0x0110,0x0111,0x0126,0x0127,0x0131,0x0132,0x0133,0x0138,0x013F,0x0140,0x0141,0x0142,0x0149,0x014A,0x014B,0x0152,0x0153,0x0166,0x0167,0x017F,0x0180,0x0181,0x0182,0x0183,0x0187,0x0188,0x0189,0x018A,0x018B,0x018C,0x0190,0x0191,0x0192,0x0193,0x0195,0x0196,0x0197,0x0198,0x0199,0x019A,0x019D,0x019E,0x01A2,0x01A3,0x01A4,0x01A5,0x01AB,0x01AC,0x01AD,0x01AE,0x01B2,0x01B3,0x01B4,0x01B5,0x01B6,0x01C4,0x01C5,0x01C6,0x01C7,0x01C8,0x01C9,0x01CA,0x01CB,0x01CC,0x01E4,0x01E5,0x01F1,0x01F2,0x01F3,0x0221,0x0224,0x0225,0x0234,0x0235,0x0236,0x0237,0x0238,0x0239,0x023A,0x023B,0x023C,0x023D,0x023E,0x023F,0x0240,0x0243,0x0244,0x0246,0x0247,0x0248,0x0249,0x024C,0x024D,0x024E,0x024F,0x0253,0x0255,0x0256,0x0257,0x025B,0x025F,0x0260,0x0261,0x0262,0x0266,0x0267,0x0268,0x026A,0x026B,0x026C,0x026D,0x0271,0x0272,0x0273,0x0274,0x0276,0x027C,0x027D,0x027E,0x0280,0x0282,0x0288,0x0289,0x028B,0x028F,0x0290,0x0291,0x0299,0x029B,0x029C,0x029D,0x029F,0x02A0,0x02A3,0x02A5,0x02A6,0x02AA,0x02AB,0x1D00,0x1D01,0x1D03,0x1D04,0x1D05,0x1D06,0x1D07,0x1D0A,0x1D0B,0x1D0C,0x1D0D,0x1D0F,0x1D18,0x1D1B,0x1D1C,0x1D20,0x1D21,0x1D22,0x1D6B,0x1D6C,0x1D6D,0x1D6E,0x1D6F,0x1D70,0x1D71,0x1D72,0x1D73,0x1D74,0x1D75,0x1D76,0x1D7A,0x1D7B,0x1D7D,0x1D7E,0x1D80,0x1D81,0x1D82,0x1D83,0x1D84,0x1D85,0x1D86,0x1D87,0x1D88,0x1D89,0x1D8A,0x1D8C,0x1D8D,0x1D8E,0x1D8F,0x1D91,0x1D92,0x1D93,0x1D96,0x1D99,0x1E9A,0x1E9C,0x1E9D,0x1E9E,0x1EFA,0x1EFB,0x1EFC,0x1EFD,0x1EFE,0x1EFF,0x2C60,0x2C61,0x2C62,0x2C63,0x2C64,0x2C65,0x2C66,0x2C67,0x2C68,0x2C69,0x2C6A,0x2C6B,0x2C6C,0x2C6E,0x2C71,0x2C72,0x2C73,0x2C74,0x2C78,0x2C7A,0x2C7E,0x2C7F,0xA730,0xA731,0xA732,0xA733,0xA734,0xA735,0xA736,0xA737,0xA738,0xA739,0xA73A,0xA73B,0xA73C,0xA73D,0xA740,0xA741,0xA742,0xA743,0xA744,0xA745,0xA746,0xA747,0xA748,0xA749,0xA74A,0xA74B,0xA74C,0xA74D,0xA74E,0xA74F,0xA750,0xA751,0xA752,0xA753,0xA754,0xA755,0xA756,0xA757,0xA758,0xA759,0xA75E,0xA75F,0xA760,0xA761,0xA764,0xA765,0xA766,0xA767,0xA771,0xA772,0xA773,0xA774,0xA775,0xA776,0xA777,0xA779,0xA77A,0xA77B,0xA77C,0xA786,0xA787,0xA790,0xA791,0xA792,0xA793,0xA7A0,0xA7A1,0xA7A2,0xA7A3,0xA7A4,0xA7A5,0xA7A6,0xA7A7,0xA7A8,0xA7A9,0xA7AA,0xFB00,0xFB01,0xFB02,0xFB03,0xFB04,0xFB05,0xFB06,0xFF21,0xFF22,0xFF23,0xFF24,0xFF25,0xFF26,0xFF27,0xFF28,0xFF29,0xFF2A,0xFF2B,0xFF2C,0xFF2D,0xFF2E,0xFF2F,0xFF30,0xFF31,0xFF32,0xFF33,0xFF34,0xFF35,0xFF36,0xFF37,0xFF38,0xFF39,0xFF3A,0xFF41,0xFF42,0xFF43,0xFF44,0xFF45,0xFF46,0xFF47,0xFF48,0xFF49,0xFF4A,0xFF4B,0xFF4C,0xFF4D,0xFF4E,0xFF4F,0xFF50,0xFF51,0xFF52,0xFF53,0xFF54,0xFF55,0xFF56,0xFF57,0xFF58,0xFF59,0xFF5A,0x00A9,0x00AE,0x20A0,0x20A2,0x20A3,0x20A4,0x20A7,0x20B9,0x20BA,0x2100,0x2101,0x2102,0x2105,0x2106,0x210A,0x210B,0x210C,0x210D,0x210E,0x2110,0x2111,0x2112,0x2113,0x2115,0x2116,0x2117,0x2118,0x2119,0x211A,0x211B,0x211C,0x211D,0x211E,0x2121,0x2124,0x2128,0x212C,0x212D,0x212F,0x2130,0x2131,0x2133,0x2134,0x2139,0x213B,0x2145,0x2146,0x2147,0x2148,0x2149,0x3371,0x3372,0x3373,0x3374,0x3375,0x3376,0x3377,0x337A,0x3380,0x3381,0x3383,0x3384,0x3385,0x3386,0x3387,0x3388,0x3389,0x338A,0x338B,0x338E,0x338F,0x3390,0x3391,0x3392,0x3393,0x3394,0x3399,0x339A,0x339C,0x339D,0x339E,0x33A7,0x33A9,0x33AA,0x33AB,0x33AC,0x33AD,0x33AE,0x33B0,0x33B1,0x33B3,0x33B4,0x33B5,0x33B7,0x33B8,0x33B9,0x33BA,0x33BB,0x33BD,0x33BE,0x33BF,0x33C2,0x33C3,0x33C4,0x33C5,0x33C6,0x33C7,0x33C8,0x33C9,0x33CA,0x33CB,0x33CC,0x33CD,0x33CE,0x33CF,0x33D0,0x33D1,0x33D2,0x33D3,0x33D4,0x33D5,0x33D6,0x33D7,0x33D8,0x33D9,0x33DA,0x33DB,0x33DC,0x33DD,0x33DE,0x33DF,0x249C,0x249D,0x249E,0x249F,0x24A0,0x24A1,0x24A2,0x24A3,0x24A4,0x24A5,0x24A6,0x24A7,0x24A8,0x24A9,0x24AA,0x24AB,0x24AC,0x24AD,0x24AE,0x24AF,0x24B0,0x24B1,0x24B2,0x24B3,0x24B4,0x24B5,0x1F110,0x1F111,0x1F112,0x1F113,0x1F114,0x1F115,0x1F116,0x1F117,0x1F118,0x1F119,0x1F11A,0x1F11B,0x1F11C,0x1F11D,0x1F11E,0x1F11F,0x1F120,0x1F121,0x1F122,0x1F123,0x1F124,0x1F125,0x1F126,0x1F127,0x1F128,0x1F129,0x2160,0x2161,0x2162,0x2163,0x2164,0x2165,0x2166,0x2167,0x2168,0x2169,0x216A,0x216B,0x216C,0x216D,0x216E,0x216F,0x2170,0x2171,0x2172,0x2173,0x2174,0x2175,0x2176,0x2177,0x2178,0x2179,0x217A,0x217B,0x217C,0x217D,0x217E,0x217F,0x00BC,0x00BD,0x00BE,0x2150,0x2151,0x2152,0x2153,0x2154,0x2155,0x2156,0x2157,0x2158,0x2159,0x215A,0x215B,0x215C,0x215D,0x215E,0x215F,0x2189,0x2474,0x2475,0x2476,0x2477,0x2478,0x2479,0x247A,0x247B,0x247C,0x247D,0x247E,0x247F,0x2480,0x2481,0x2482,0x2483,0x2484,0x2485,0x2486,0x2487,0x1F100,0x2488,0x2489,0x248A,0x248B,0x248C,0x248D,0x248E,0x248F,0x2490,0x2491,0x2492,0x2493,0x2494,0x2495,0x2496,0x2497,0x2498,0x2499,0x249A,0x249B,0x1F101,0x1F102,0x1F103,0x1F104,0x1F105,0x1F106,0x1F107,0x1F108,0x1F109,0x1F10A,0x3007,0xFF10,0xFF11,0xFF12,0xFF13,0xFF14,0xFF15,0xFF16,0xFF17,0xFF18,0xFF19,\u00A0,\u2002,\u2003,\u2004,\u2005,\u2006,\u2007,\u2008,\u2009,\u200A,\u205F,\u3000,0x02B9,0x02BA,0x02BB,0x02BC,0x02BD,0x02C8,0x02CB,0x2018,0x2019,0x201A,0x201B,0x201C,0x201D,0x201E,0x201F,0x2032,0x2033,0x301D,0x301E,0xFF02,0xFF07,0x00AB,0x00BB,0x2039,0x203A,\u00AD,0x2010,0x2011,0x2012,0x2013,0x2014,0x2015,0xFE31,0xFE32,0xFE58,0xFE63,0xFF0D,0x00A1,0x00BF,0x02C2,0x02C3,0x02C4,0x02C6,0x02D0,0x02DC,0x2016,0x2024,0x2025,0x2026,0x203C,0x2044,0x2045,0x2046,0x2047,0x2048,0x2049,0x204E,0x2190,0x,0x2194,0xFFE9,0xFFEB,0x3001,0x3002,0x3008,0x3009,0x300A,0x300B,0x3014,0x3015,0x3018,0x3019,0x301A,0x301B,0xFE10,0xFE11,0xFE12,0xFE13,0xFE14,0xFE15,0xFE16,0xFE19,0xFE30,0xFE35,0xFE36,0xFE37,0xFE38,0xFE39,0xFE3A,0xFE3D,0xFE3E,0xFE3F,0xFE40,0xFE47,0xFE48,0xFE50,0xFE51,0xFE52,0xFE54,0xFE55,0xFE56,0xFE57,0xFE59,0xFE5A,0xFE5B,0xFE5C,0xFE5D,0xFE5E,0xFE5F,0xFE60,0xFE61,0xFE62,0xFE64,0xFE65,0xFE66,0xFE68,0xFE69,0xFE6A,0xFE6B,0xFF01,0xFF03,0xFF04,0xFF05,0xFF06,0xFF08,0xFF09,0xFF0A,0xFF0B,0xFF0C,0xFF0E,0xFF0F,0xFF1A,0xFF1B,0xFF1C,0xFF1D,0xFF1E,0xFF1F,0xFF20,0xFF3B,0xFF3C,0xFF3D,0xFF3E,0xFF3F,0xFF40,0xFF5B,0xFF5C,0xFF5D,0xFF5E,0xFF5F,0xFF60,0xFF61,0xFF64,0x00B1,0x00D7,0x00F7,0x02D6,0x02D7,0x2212,0x2215,0x2216,0x2223,0x2225,0x226A,0x226B,0x2985,0x2986,0x2A74,0x2A75,0x2A76};

    // The codepoint map auto-generated by python script
    const static std::unordered_map<codepoint_t, codepoint_t> explicit_cp_data = {{0xFF01, 0x0021}, {0xFF02, 0x0022}, {0xFF03, 0x0023}, {0xFF04, 0x0024}, {0xFF05, 0x0025}, {0xFF06, 0x0026}, {0xFF07, 0x0027}, {0xFF08, 0x0028}, {0xFF09, 0x0029}, {0xFF0A, 0x002A}, {0xFF0B, 0x002B}, {0xFF0C, 0x002C}, {0xFF0D, 0x002D}, {0xFF0E, 0x002E}, {0xFF0F, 0x002F}, {0xFF10, 0x0030}, {0xFF11, 0x0031}, {0xFF12, 0x0032}, {0xFF13, 0x0033}, {0xFF14, 0x0034}, {0xFF15, 0x0035}, 
{0xFF16, 0x0036}, {0xFF17, 0x0037}, {0xFF18, 0x0038}, {0xFF19, 0x0039}, {0xFF1A, 0x003A}, {0xFF1B, 0x003B}, {0xFF1C, 0x003C}, {0xFF1D, 0x003D}, {0xFF1E, 0x003E}, {0xFF1F, 0x003F}, {0xFF20, 0x0040}, {0xFF21, 0x0041}, {0xFF22, 0x0042}, {0xFF23, 0x0043}, {0xFF24, 0x0044}, {0xFF25, 0x0045}, {0xFF26, 0x0046}, {0xFF27, 0x0047}, {0xFF28, 0x0048}, {0xFF29, 0x0049}, {0xFF2A, 0x004A}, {0xFF2B, 0x004B}, {0xFF2C, 0x004C}, {0xFF2D, 0x004D}, {0xFF2E, 0x004E}, {0xFF2F, 0x004F}, {0xFF30, 0x0050}, {0xFF31, 0x0051}, {0xFF32, 0x0052}, {0xFF33, 0x0053}, {0xFF34, 0x0054}, {0xFF35, 0x0055}, {0xFF36, 0x0056}, {0xFF37, 0x0057}, {0xFF38, 0x0058}, {0xFF39, 0x0059}, {0xFF3A, 0x005A}, {0xFF3B, 0x005B}, {0xFF3C, 0x005C}, {0xFF3D, 0x005D}, {0xFF3E, 0x005E}, {0xFF3F, 0x005F}, {0xFF40, 0x0060}, {0xFF41, 0x0061}, {0xFF42, 0x0062}, {0xFF43, 0x0063}, {0xFF44, 0x0064}, {0xFF45, 0x0065}, {0xFF46, 0x0066}, {0xFF47, 0x0067}, {0xFF48, 0x0068}, {0xFF49, 0x0069}, {0xFF4A, 0x006A}, {0xFF4B, 0x006B}, {0xFF4C, 0x006C}, {0xFF4D, 0x006D}, {0xFF4E, 0x006E}, {0xFF4F, 0x006F}, {0xFF50, 0x0070}, {0xFF51, 0x0071}, {0xFF52, 0x0072}, {0xFF53, 0x0073}, {0xFF54, 0x0074}, {0xFF55, 0x0075}, {0xFF56, 0x0076}, {0xFF57, 0x0077}, {0xFF58, 0x0078}, {0xFF59, 0x0079}, {0xFF5A, 0x007A}, {0xFF5B, 0x007B}, {0xFF5C, 0x007C}, {0xFF5D, 0x007D}, {0x11A8, 0xFFA1}, {0x11A9, 0xFFA2}, {0x11AA, 0xFFA3}, {0x11AB, 0xFFA4}, 
{0x11AC, 0xFFA5}, {0x11AD, 0xFFA6}, {0x11AE, 0xFFA7}, {0x1104, 0xFFA8}, {0x11AF, 0xFFA9}, {0x11B0, 0xFFAA}, {0x11B1, 0xFFAB}, {0x11B2, 0xFFAC}, {0x11B3, 0xFFAD}, {0x11B4, 0xFFAE}, {0x11B5, 0xFFAF}, {0x11B6, 0xFFB0}, {0x11B7, 0xFFB1}, {0x11B8, 0xFFB2}, {0x11B9, 0xFFB4}, {0x1108, 0xFFB3}, {0x11BA, 0xFFB5}, {0x11BB, 0xFFB6}, {0x11BC, 0xFFB7}, {0x11BD, 0xFFB8}, {0x11BE, 0xFFBA}, {0x110D, 0xFFB9}, {0x11BF, 0xFFBB}, {0x11C0, 0xFFBC}, {0x11C1, 0xFFBD}, {0x11C2, 0xFFBE}, {0x1161, 0xFFC2}, {0x1162, 0xFFC3}, {0x1163, 0xFFC4}, {0x1164, 0xFFC5}, {0x1165, 0xFFC6}, {0x1166, 0xFFC7}, {0x1167, 0xFFCA}, {0x1168, 0xFFCB}, {0x1169, 0xFFCC}, {0x116A, 0xFFCD}, {0x116B, 0xFFCE}, {0x116C, 0xFFCF}, {0x116D, 0xFFD2}, {0x116E, 0xFFD3}, {0x116F, 0xFFD4}, {0x1170, 0xFFD5}, {0x1171, 0xFFD6}, {0x1172, 0xFFD7}, {0x1173, 0xFFDA}, {0x1174, 0xFFDB}, {0x1175, 0xFFDC}, {0x30F2, 0xFF66}, {0x30A1, 0xFF67}, {0x30A2, 0xFF71}, {0x30A3, 0xFF68}, {0x30A4, 0xFF72}, {0x30A5, 0xFF69}, {0x30A6, 0xFF73}, {0x30A7, 0xFF6A}, {0x30A8, 0xFF74}, {0x30A9, 0xFF6B}, {0x30AA, 0xFF75}, {0x30AB, 0xFF76}, {0x30AD, 0xFF77}, {0x30AF, 0xFF78}, {0x30B1, 0xFF79}, {0x30B3, 0xFF7A}, {0x30B5, 0xFF7B}, {0x30B7, 0xFF7C}, {0x30B9, 0xFF7D}, {0x30BB, 0xFF7E}, {0x30BD, 0xFF7F}, {0x30BF, 0xFF80}, {0x30C1, 0xFF81}, {0x30C3, 0xFF6F}, {0x30C4, 0xFF82}, {0x30C6, 0xFF83}, {0x30C8, 0xFF84}, {0x30CA, 0xFF85}, {0x30CB, 0xFF86}, 
{0x30CC, 0xFF87}, {0x30CD, 0xFF88}, {0x30CE, 0xFF89}, {0x30CF, 0xFF8A}, {0x30D2, 0xFF8B}, {0x30D5, 0xFF8C}, {0x30D8, 0xFF8D}, {0x30DB, 0xFF8E}, {0x30DE, 0xFF8F}, {0x30DF, 0xFF90}, {0x30E0, 0xFF91}, {0x30E1, 0xFF92}, {0x30E2, 0xFF93}, {0x30E3, 0xFF6C}, {0x30E4, 0xFF94}, {0x30E5, 0xFF6D}, {0x30E6, 0xFF95}, {0x30E7, 0xFF6E}, {0x30E8, 0xFF96}, {0x30E9, 0xFF97}, {0x30EA, 0xFF98}, {0x30EB, 0xFF99}, {0x30EC, 0xFF9A}, {0x30ED, 0xFF9B}, {0x30EF, 0xFF9C}, {0x30F3, 0xFF9D}, {0x309C, 0xFF9F}, {0x3099, 0xFF9E}, {0x309B, 0xFF9E}, {0x30FC, 0xFF70}, {0x30FB, 0xFF65}, {0xFF5F, 0x2985}, {0xFF60, 0x2986 }, {0x3002, 0xFF61}, {0x300C, 0xFF62}, {0x300D, 0xFF63}, {0x3001, 0xFF64}, {0xFFE0, 0x00A2}, {0xFFE1, 0x00A3}, {0xFFE2, 0x00AC}, {0xFFE3, 0x00AF}, {0xFFE4, 0x00A6}, {0xFFE5, 0x00A5}, {0xFFE6, 0x20A9}, {0x2502, 0xFFE8}, {0x2190, 0xFFE9}, {0x2191, 0xFFEA}, {0x2192, 0xFFEB}, {0x2193, 0xFFEC}, {0x25A0, 0xFFED}, {0x25CB, 0xFFEE}};

    unicode::TranslationMap mExplicitCodepointMap = (unicode::TranslationMap) explicit_cp_data;
    unicode::BitTranslationSets fullHalfTranslationSet = unicode::ComputeBitTranslationSets(mExplicitCodepointMap);

    // Turn the fullHalf translation set into a vector of character classes
    std::vector<re::CC *> fullHalfTranslation_ccs;
    for (auto & b : fullHalfTranslationSet) {
        fullHalfTranslation_ccs.push_back(re::makeCC(b, &cc::Unicode));
    }

    StreamSet * translationBasis = P->CreateStreamSet(fullHalfTranslation_ccs.size());
    P->CreateKernelCall<CharClassesKernel>(fullHalfTranslation_ccs, U21, translationBasis);
    SHOW_BIXNUM(translationBasis);

    // Perform the logic of the FullHalfify kernel on the codepoiont values.
    StreamSet * u32Basis = P->CreateStreamSet(21, 1);
    P->CreateKernelCall<FullHalfify>(U21, translationBasis, u32Basis);
    SHOW_BIXNUM(u32Basis);

    // Convert back to UTF8 from codepoints.
    StreamSet * const OutputBasis = P->CreateStreamSet(8);
    U21_to_UTF8(P, u32Basis, OutputBasis);

    SHOW_BIXNUM(OutputBasis);

    StreamSet * OutputBytes = P->CreateStreamSet(1, 8);
    P->CreateKernelCall<P2SKernel>(OutputBasis, OutputBytes);
    P->CreateKernelCall<StdOutKernel>(OutputBytes);

    return reinterpret_cast<ToFullHalfFunctionType>(P->compile());
}

int main(int argc, char *argv[]) {
    //  ParseCommandLineOptions uses the LLVM CommandLine processor, but we also add
    //  standard Parabix command line options such as -help, -ShowPablo and many others.
    codegen::ParseCommandLineOptions(argc, argv, {&FullHalfOptions, pablo::pablo_toolchain_flags(), codegen::codegen_flags()});

    //  A CPU driver is capable of compiling and running Parabix programs on the CPU.
    CPUDriver driver("tofullHalf");

    //  Build and compile the Parabix pipeline by calling the Pipeline function above.
    ToFullHalfFunctionType fn = generatePipeline(driver);
    
    //  The compile function "fn"  can now be used.   It takes a file
    //  descriptor as an input, which is specified by the filename given by
    //  the inputFile command line option.
    const int fd = open(inputFile.c_str(), O_RDONLY);
    if (LLVM_UNLIKELY(fd == -1)) {
        llvm::errs() << "Error: cannot open " << inputFile << " for processing. Skipped.\n";
    } else {
        //  Run the pipeline.
        fn(fd);
        close(fd);
    }
    return 0;
}