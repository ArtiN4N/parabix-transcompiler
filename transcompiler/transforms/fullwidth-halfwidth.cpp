#include <vector>
#include <fcntl.h>
#include <string>
#include <iostream>

#include <unicode/data/PropertyObjects.h>
#include <unicode/data/PropertyObjectTable.h>
#include <unicode/core/unicode_set.h>
#include <unicode/utf/utf_compiler.h>
#include <unicode/utf/transchar.h>

#include <kernel/streamutils/deletion.h>
#include <kernel/pipeline/driver/cpudriver.h>
#include <kernel/pipeline/pipeline_builder.h>
#include <kernel/unicode/UCD_property_kernel.h>
#include <kernel/unicode/utf8_decoder.h>
#include <kernel/unicode/charclasses.h>
#include <kernel/unicode/utf8gen.h>
#include <kernel/basis/s2p_kernel.h>
#include <kernel/basis/p2s_kernel.h>
#include <kernel/core/kernel_builder.h>
#include <kernel/io/source_kernel.h>
#include <kernel/io/stdout_kernel.h>

#include <pablo/codegenstate.h>

#include <grep/grep_kernel.h>

#include <llvm/Support/CommandLine.h>
#include <llvm/Support/ErrorHandling.h>
#include <llvm/Support/raw_ostream.h>

#include <re/toolchain/toolchain.h>
#include <re/adt/re_name.h>
#include <re/adt/re_re.h>
#include <re/cc/cc_compiler_target.h>
#include <re/cc/cc_compiler.h>
#include <re/cc/cc_kernel.h>


#define SHOW_STREAM(name) if (codegen::EnableIllustrator) P->captureBitstream(#name, name)
#define SHOW_BIXNUM(name) if (codegen::EnableIllustrator) P->captureBixNum(#name, name)
#define SHOW_BYTES(name) if (codegen::EnableIllustrator) P->captureByteData(#name, name)

using namespace kernel;
using namespace llvm;
using namespace pablo;

//  These declarations are for command line processing.
//  See the LLVM CommandLine 2.0 Library Manual https://llvm.org/docs/CommandLine.html
static cl::OptionCategory FullHalfOptions("fullHalf Options", "fullHalf control options.");
static cl::opt<std::string> inputFile(cl::Positional, cl::desc("<input file>"), cl::Required, cl::cat(FullHalfOptions));

class FullHalfify : public pablo::PabloKernel {
public:
    FullHalfify(KernelBuilder & b, StreamSet * U21, StreamSet * translationBasis, StreamSet * u32Basis)
    : pablo::PabloKernel(b, "FullHalfify",
                        {Binding{"U21", U21}, Binding{"translationBasis", translationBasis}},
                            {Binding{"u32Basis", u32Basis}}) {}
protected:
    void generatePabloMethod() override;
};

void FullHalfify::generatePabloMethod() {
    //  pb is an object used for build Pablo language statements
    pablo::PabloBuilder pb(getEntryScope());

    // Get the input stream sets.
    std::vector<PabloAST *> U21 = getInputStreamSet("U21");

    std::vector<PabloAST *> translationBasis = getInputStreamSet("translationBasis");
    std::vector<PabloAST *> transformed(U21.size());

    Var * outputBasisVar = getOutputStreamVar("u32Basis");

    // For each bit of the input stream
    for (unsigned i = 0; i < U21.size(); i++) {
        // If the translation set covers said bit
        if (i < translationBasis.size()) // XOR the input bit with the transformation bit  
            transformed[i] = pb.createXor(translationBasis[i], U21[i]);
        else transformed[i] = U21[i];

        pb.createAssign(pb.createExtract(outputBasisVar, pb.getInteger(i)), transformed[i]);
    }
}


typedef void (*ToFullHalfFunctionType)(uint32_t fd);

ToFullHalfFunctionType generatePipeline(CPUDriver & pxDriver) {
    // A Parabix program is build as a set of kernel calls called a pipeline.
    // A pipeline is construction using a Parabix driver object.
    auto & b = pxDriver.getBuilder();
    auto P = pxDriver.makePipeline({Binding{b.getInt32Ty(), "inputFileDecriptor"}}, {});

    //  The program will use a file descriptor as an input.
    Scalar * fileDescriptor = P->getInputScalar("inputFileDecriptor");
    StreamSet * ByteStream = P->CreateStreamSet(1, 8);

    //  ReadSourceKernel is a Parabix Kernel that produces a stream of bytes
    //  from a file descriptor.
    P->CreateKernelCall<ReadSourceKernel>(fileDescriptor, ByteStream);
    SHOW_BYTES(ByteStream);

    // Get the basis bits
    StreamSet * BasisBits = P->CreateStreamSet(8, 1);
    P->CreateKernelCall<S2PKernel>(ByteStream, BasisBits);
    SHOW_BIXNUM(BasisBits);

    // Convert into codepoints
    StreamSet * u8index = P->CreateStreamSet(1, 1);
    P->CreateKernelCall<UTF8_index>(BasisBits, u8index);
    SHOW_STREAM(u8index);

    StreamSet * U21_u8indexed = P->CreateStreamSet(21, 1);
    P->CreateKernelCall<UTF8_Decoder>(BasisBits, U21_u8indexed);

    StreamSet * U21 = P->CreateStreamSet(21, 1);
    FilterByMask(P, u8index, U21_u8indexed, U21);
    SHOW_BIXNUM(U21);

    // The codepoint map auto-generated by python script
    const static std::unordered_map<codepoint_t, codepoint_t> explicit_cp_data = {{0xFF01, 0x0021}, {0xFF02, 0x0022}, {0xFF03, 0x0023}, {0xFF04, 0x0024}, {0xFF05, 0x0025}, {0xFF06, 0x0026}, {0xFF07, 0x0027}, {0xFF08, 0x0028}, {0xFF09, 0x0029}, {0xFF0A, 0x002A}, {0xFF0B, 0x002B}, {0xFF0C, 0x002C}, {0xFF0D, 0x002D}, {0xFF0E, 0x002E}, {0xFF0F, 0x002F}, {0xFF10, 0x0030}, {0xFF11, 0x0031}, {0xFF12, 0x0032}, {0xFF13, 0x0033}, {0xFF14, 0x0034}, {0xFF15, 0x0035}, 
{0xFF16, 0x0036}, {0xFF17, 0x0037}, {0xFF18, 0x0038}, {0xFF19, 0x0039}, {0xFF1A, 0x003A}, {0xFF1B, 0x003B}, {0xFF1C, 0x003C}, {0xFF1D, 0x003D}, {0xFF1E, 0x003E}, {0xFF1F, 0x003F}, {0xFF20, 0x0040}, {0xFF21, 0x0041}, {0xFF22, 0x0042}, {0xFF23, 0x0043}, {0xFF24, 0x0044}, {0xFF25, 0x0045}, {0xFF26, 0x0046}, {0xFF27, 0x0047}, {0xFF28, 0x0048}, {0xFF29, 0x0049}, {0xFF2A, 0x004A}, {0xFF2B, 0x004B}, {0xFF2C, 0x004C}, {0xFF2D, 0x004D}, {0xFF2E, 0x004E}, {0xFF2F, 0x004F}, {0xFF30, 0x0050}, {0xFF31, 0x0051}, {0xFF32, 0x0052}, {0xFF33, 0x0053}, {0xFF34, 0x0054}, {0xFF35, 0x0055}, {0xFF36, 0x0056}, {0xFF37, 0x0057}, {0xFF38, 0x0058}, {0xFF39, 0x0059}, {0xFF3A, 0x005A}, {0xFF3B, 0x005B}, {0xFF3C, 0x005C}, {0xFF3D, 0x005D}, {0xFF3E, 0x005E}, {0xFF3F, 0x005F}, {0xFF40, 0x0060}, {0xFF41, 0x0061}, {0xFF42, 0x0062}, {0xFF43, 0x0063}, {0xFF44, 0x0064}, {0xFF45, 0x0065}, {0xFF46, 0x0066}, {0xFF47, 0x0067}, {0xFF48, 0x0068}, {0xFF49, 0x0069}, {0xFF4A, 0x006A}, {0xFF4B, 0x006B}, {0xFF4C, 0x006C}, {0xFF4D, 0x006D}, {0xFF4E, 0x006E}, {0xFF4F, 0x006F}, {0xFF50, 0x0070}, {0xFF51, 0x0071}, {0xFF52, 0x0072}, {0xFF53, 0x0073}, {0xFF54, 0x0074}, {0xFF55, 0x0075}, {0xFF56, 0x0076}, {0xFF57, 0x0077}, {0xFF58, 0x0078}, {0xFF59, 0x0079}, {0xFF5A, 0x007A}, {0xFF5B, 0x007B}, {0xFF5C, 0x007C}, {0xFF5D, 0x007D}, {0x11A8, 0xFFA1}, {0x11A9, 0xFFA2}, {0x11AA, 0xFFA3}, {0x11AB, 0xFFA4}, 
{0x11AC, 0xFFA5}, {0x11AD, 0xFFA6}, {0x11AE, 0xFFA7}, {0x1104, 0xFFA8}, {0x11AF, 0xFFA9}, {0x11B0, 0xFFAA}, {0x11B1, 0xFFAB}, {0x11B2, 0xFFAC}, {0x11B3, 0xFFAD}, {0x11B4, 0xFFAE}, {0x11B5, 0xFFAF}, {0x11B6, 0xFFB0}, {0x11B7, 0xFFB1}, {0x11B8, 0xFFB2}, {0x11B9, 0xFFB4}, {0x1108, 0xFFB3}, {0x11BA, 0xFFB5}, {0x11BB, 0xFFB6}, {0x11BC, 0xFFB7}, {0x11BD, 0xFFB8}, {0x11BE, 0xFFBA}, {0x110D, 0xFFB9}, {0x11BF, 0xFFBB}, {0x11C0, 0xFFBC}, {0x11C1, 0xFFBD}, {0x11C2, 0xFFBE}, {0x1161, 0xFFC2}, {0x1162, 0xFFC3}, {0x1163, 0xFFC4}, {0x1164, 0xFFC5}, {0x1165, 0xFFC6}, {0x1166, 0xFFC7}, {0x1167, 0xFFCA}, {0x1168, 0xFFCB}, {0x1169, 0xFFCC}, {0x116A, 0xFFCD}, {0x116B, 0xFFCE}, {0x116C, 0xFFCF}, {0x116D, 0xFFD2}, {0x116E, 0xFFD3}, {0x116F, 0xFFD4}, {0x1170, 0xFFD5}, {0x1171, 0xFFD6}, {0x1172, 0xFFD7}, {0x1173, 0xFFDA}, {0x1174, 0xFFDB}, {0x1175, 0xFFDC}, {0x30F2, 0xFF66}, {0x30A1, 0xFF67}, {0x30A2, 0xFF71}, {0x30A3, 0xFF68}, {0x30A4, 0xFF72}, {0x30A5, 0xFF69}, {0x30A6, 0xFF73}, {0x30A7, 0xFF6A}, {0x30A8, 0xFF74}, {0x30A9, 0xFF6B}, {0x30AA, 0xFF75}, {0x30AB, 0xFF76}, {0x30AD, 0xFF77}, {0x30AF, 0xFF78}, {0x30B1, 0xFF79}, {0x30B3, 0xFF7A}, {0x30B5, 0xFF7B}, {0x30B7, 0xFF7C}, {0x30B9, 0xFF7D}, {0x30BB, 0xFF7E}, {0x30BD, 0xFF7F}, {0x30BF, 0xFF80}, {0x30C1, 0xFF81}, {0x30C3, 0xFF6F}, {0x30C4, 0xFF82}, {0x30C6, 0xFF83}, {0x30C8, 0xFF84}, {0x30CA, 0xFF85}, {0x30CB, 0xFF86}, 
{0x30CC, 0xFF87}, {0x30CD, 0xFF88}, {0x30CE, 0xFF89}, {0x30CF, 0xFF8A}, {0x30D2, 0xFF8B}, {0x30D5, 0xFF8C}, {0x30D8, 0xFF8D}, {0x30DB, 0xFF8E}, {0x30DE, 0xFF8F}, {0x30DF, 0xFF90}, {0x30E0, 0xFF91}, {0x30E1, 0xFF92}, {0x30E2, 0xFF93}, {0x30E3, 0xFF6C}, {0x30E4, 0xFF94}, {0x30E5, 0xFF6D}, {0x30E6, 0xFF95}, {0x30E7, 0xFF6E}, {0x30E8, 0xFF96}, {0x30E9, 0xFF97}, {0x30EA, 0xFF98}, {0x30EB, 0xFF99}, {0x30EC, 0xFF9A}, {0x30ED, 0xFF9B}, {0x30EF, 0xFF9C}, {0x30F3, 0xFF9D}, {0x309C, 0xFF9F}, {0x309B, 0xFF9E}, {0x30FC, 0xFF70}, {0x30FB, 0xFF65}};

    unicode::TranslationMap mExplicitCodepointMap = (unicode::TranslationMap) explicit_cp_data;

    for (const auto& pair : mExplicitCodepointMap) {
        std::cout << "Key: " << pair.first << ", Value: " << pair.second << std::endl;
    }

    unicode::BitTranslationSets fullHalfTranslationSet = unicode::ComputeBitTranslationSets(mExplicitCodepointMap);

    // Get the fullHalfcase mapping object, can create a translation set from that
    //UCD::CodePointPropertyObject* fullHalfPropertyObject = dyn_cast<UCD::CodePointPropertyObject>(UCD::get_SLC_PropertyObject());
    //unicode::BitTranslationSets fullHalfTranslationSet;
    //fullHalfTranslationSet = fullHalfPropertyObject->GetBitTransformSets();

    // Turn the fullHalf translation set into a vector of character classes
    std::vector<re::CC *> fullHalfTranslation_ccs;
    for (auto & b : fullHalfTranslationSet) {
        fullHalfTranslation_ccs.push_back(re::makeCC(b, &cc::Unicode));
    }

    StreamSet * translationBasis = P->CreateStreamSet(fullHalfTranslation_ccs.size());
    P->CreateKernelCall<CharClassesKernel>(fullHalfTranslation_ccs, U21, translationBasis);
    SHOW_BIXNUM(translationBasis);

    // Perform the logic of the FullHalfify kernel on the codepoiont values.
    StreamSet * u32Basis = P->CreateStreamSet(21, 1);
    P->CreateKernelCall<FullHalfify>(U21, translationBasis, u32Basis);
    SHOW_BIXNUM(u32Basis);

    // Convert back to UTF8 from codepoints.
    StreamSet * const OutputBasis = P->CreateStreamSet(8);
    U21_to_UTF8(P, u32Basis, OutputBasis);

    SHOW_BIXNUM(OutputBasis);

    StreamSet * OutputBytes = P->CreateStreamSet(1, 8);
    P->CreateKernelCall<P2SKernel>(OutputBasis, OutputBytes);
    P->CreateKernelCall<StdOutKernel>(OutputBytes);

    return reinterpret_cast<ToFullHalfFunctionType>(P->compile());
}

int main(int argc, char *argv[]) {
    //  ParseCommandLineOptions uses the LLVM CommandLine processor, but we also add
    //  standard Parabix command line options such as -help, -ShowPablo and many others.
    codegen::ParseCommandLineOptions(argc, argv, {&FullHalfOptions, pablo::pablo_toolchain_flags(), codegen::codegen_flags()});

    //  A CPU driver is capable of compiling and running Parabix programs on the CPU.
    CPUDriver driver("tofullHalf");

    //  Build and compile the Parabix pipeline by calling the Pipeline function above.
    ToFullHalfFunctionType fn = generatePipeline(driver);
    
    //  The compile function "fn"  can now be used.   It takes a file
    //  descriptor as an input, which is specified by the filename given by
    //  the inputFile command line option.
    const int fd = open(inputFile.c_str(), O_RDONLY);
    if (LLVM_UNLIKELY(fd == -1)) {
        llvm::errs() << "Error: cannot open " << inputFile << " for processing. Skipped.\n";
    } else {
        //  Run the pipeline.
        fn(fd);
        close(fd);
    }
    return 0;
}