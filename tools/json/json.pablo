#
# Copyright (c) 2019 International Characters.
# This software is licensed to the public under the Open Software License 3.0.
#

type BasisBits = <i1>[8]

type Err = <i1>[2] {
    escapedStr,
    utf8
}

type Lex = <i1>[14] {
    lCurly,
    rCurly,
    lBracket,
    rBracket,
    colon,
    comma,
    dQuote,
    hyphen,
    digit,
    backslash,
    n, # first letter of null
    f, # first letter of false
    t, # first letter of true
    ws
}

# ClassifyBytes the bytes of a basis stream.
# See that there is no error at this level as
# we will validation step afterwards.
#
kernel ClassifyBytes :: [BasisBits basis] -> [Lex lex] {
    # Brackets
    # 01 1 11 01 1 = {
    # 01 1 11 10 1 = }
    # 01 0 11 01 1 = [
    # 01 0 11 10 1 = ]

    temp1 = ~basis[7] & basis[6]
    temp2 = basis[3] & basis[4]
    temp3 = basis[0] & temp2
    # left
    temp4 = basis[1] & ~basis[2]
    # right
    temp5 = ~basis[1] & basis[2]
    # curly
    temp6 = basis[5] & temp3
    temp8 = temp1 & temp6
    lex.lCurly = temp8 & temp4
    lex.rCurly = temp8 & temp5
    # bracket
    temp9 = ~basis[5] & temp3
    temp10 = temp1 & temp9
    lex.lBracket = temp10 & temp4
    lex.rBracket = temp10 & temp5

    # 00 1 11 01 0 = :
    # 00 1 00 01 0 = "
    # 00 1 01 10 0 = ,

    temp11 = ~basis[7] & ~basis[6]
    temp12 = basis[5] & temp11
    temp13 = ~basis[0] & temp12
    temp14 = basis[1] & ~basis[2]
    temp15 = ~basis[1] & basis[2]
    # colon and quotes
    temp16 = temp13 & temp14
    temp17 = basis[3] & basis[4]
    lex.colon = temp17 & temp16
    temp18 = ~basis[3] & ~basis[4]
    lex.dQuote = temp18 & temp16
    # comma
    temp19 = temp13 & temp15
    temp20 = basis[3] & ~basis[4]
    lex.comma = temp19 & temp20

    # 00 1 01 10 1 = -
    temp21 = temp12 & temp20
    temp22 = temp21 & temp15
    lex.hyphen = basis[0] & temp22

    # [0-9]
    temp23 = basis[4] & basis[5]
    temp24 = basis[6] | basis[7]
    temp25 = temp23 & ~temp24
    temp26 = basis[1] | basis[2]
    temp27 = basis[3] & temp26
    temp28 = temp25 & ~temp27
    lex.digit = InFile(temp28)

    # 010 111 00 = \
    temp29 = temp1 & ~basis[5]
    temp30 = ~basis[1] & ~basis[0]
    temp32 = basis[3] & basis[2]
    temp34 = temp30 & temp32
    temp35 = basis[4] & temp34
    lex.backslash = temp29 & temp35

    # 011 01 1 1 0 = n
    # 011 00 1 1 0 = f
    # 011 10 1 0 0 = t
    temp38 = temp1 & basis[5]
    temp39 = ~basis[0] & basis[2]
    temp40 = temp39 & basis[1]
    temp41 = temp39 & ~basis[1]
    temp42 = temp20 & temp40
    lex.n = temp42 & temp38
    temp43 = temp18 & temp40
    lex.f = temp43 & temp38
    temp44 = ~basis[3] & basis[4]
    temp45 = temp44 & temp41
    lex.t = temp45 & temp38

    # [ \n\r\t]
    # 00 10 0000 = space
    # 00 00 1010 = lf
    # 00 00 1001 = tab
    # 00 00 1101 = cr
    temp46 = ~basis[7] & ~basis[6]
    temp47 = temp46 & ~basis[4]

    other2nibs = temp47 & ~basis[5]
    space2nib = temp47 & basis[5]

    temp48 = ~basis[0] & ~basis[1]
    temp49 = ~basis[2] & ~basis[3]
    space1nib = temp48 & temp49
    space = space1nib & space2nib

    other5bits = other2nibs & basis[3]
    lfTabCommon = other5bits & ~basis[2]
    temp50 = ~basis[0] & basis[1]
    temp51 = basis[0] & ~basis[1]
    lf = lfTabCommon & temp50
    tab = lfTabCommon & temp51

    temp52 = temp51 & basis[2]
    cr = other5bits & temp52

    lfTab = lf | tab
    crSpace = cr | space

    lex.ws = lfTab | crSpace
}

type UTF8Err = <i1>[1]

kernel ValidateUTF8 :: [BasisBits basis, Lex lex] -> [UTF8Err utf8Err] {
    utf8Err[0] = <0>

    # If non-ascii, validate UTF-8
    if basis[7] {
        suffix = <0>
        u8_error = <0>
        u8_FFFE_FFFF = <0>
        u8anyscope = <0>
        unibyte = ~basis[7]

        temp2 = basis[5] & ~basis[4]
        temp4 = basis[2] & ~basis[3]
        temp5 = basis[1] & ~basis[0]
        temp7 = basis[5] & basis[4]
        temp10 = basis[1] & basis[0]
        temp12 = basis[3] & basis[2]
        temp13 = basis[1] | basis[0]
        temp15 = temp12 & temp5
        temp19 = basis[0] & ~basis[1]
        temp20 = temp12 & temp19
        temp21 = basis[3] | basis[2]
        temp23 = temp12 & temp10
        temp36 = temp21 | temp13
        temp49 = basis[5] | basis[4]
        prefix = basis[7] & basis[6]
        prefix2 = prefix & ~basis[5]
        prefix3 = prefix & temp2
        prefix4 = prefix & temp7
        suffix = basis[7] & ~basis[6]
        temp66 = prefix & ~temp49
        temp67 = temp21 | basis[1]
        temp68 = temp66 & ~temp67
        temp69 = basis[2] & temp13
        temp70 = basis[3] | temp69
        temp71 = prefix4 & temp70
        badprefix = temp68 | temp71
        u8_error = badprefix
        scope22 = Advance(prefix2)
        u8anyscope = scope22
        if prefix3 | prefix4 {
            xE0 = prefix3 & ~temp36
            xED = prefix3 & temp20
            xF0 = prefix4 & ~temp36
            temp72 = temp4 & ~temp13
            xF4 = prefix4 & temp72
            xA0_xBF = suffix & basis[5]
            x80_x9F = suffix & ~basis[5]
            x90_xBF = suffix & temp49
            x80_x8F = suffix & ~temp49
            xEF = prefix3 & temp23
            temp73 = suffix & temp7
            xBF = temp73 & temp23
            xBE = temp73 & temp15

            scope32 = Advance(prefix3)
            scope33 = Advance(scope32)
            scope42 = Advance(prefix4)
            scope43 = Advance(scope42)
            scope44 = Advance(scope43)

            E0_F0_scope = Advance(xE0 | xF0)
            ED_F4_scope = Advance(xED | xF4)
            xE0_scope = scope32 & E0_F0_scope
            xED_scope = scope32 & ED_F4_scope
            xF0_scope = scope42 & E0_F0_scope
            xF4_scope = scope42 & ED_F4_scope
            xEF_scope = Advance(xEF)

            u8lastscope = scope22 | scope33 | scope44
            u8anyscope = u8lastscope | scope32 | scope42 | scope43

            u8error1 = xE0_scope & x80_x9F
            u8error2 = xED_scope & xA0_xBF
            u8error3 = xF0_scope & x80_x8F
            u8error4 = xF4_scope & x90_xBF

            u8_error = u8_error | u8error1 | u8error2 | u8error3 | u8error4

            EF_BF_pending = Advance(xEF_scope & xBF)

            u8_FFFE_FFFF = (EF_BF_pending & (xBE | xBF))
        }
        u8mismatch = u8anyscope ^ suffix
        u8_error = u8_error | u8mismatch | u8_FFFE_FFFF

        # sanitize error
        conflict = u8_error & lex.ws
        utf8Err[0] = u8_error ^ conflict
    }
}

# Create a multiplexed streamiest for left/right brackets and braces
# mpx[0] = 1 for right, 0 for left
# mpx[1] = 1 for square bracket, 0 for brace
type MultiplexedBrackets = <i1>[2]
type Brackets = <i1>[7]
kernel MultiplexBrackets :: [Brackets brackets] -> [MultiplexedBrackets mpx] {
    rCurly = brackets[1]
    lBracket = brackets[2]
    rBracket = brackets[3]
    mpx[0] = rCurly | rBracket
    mpx[1] = rBracket | lBracket
}


type ToPostProcess = <i1>[1]
kernel DeleteInlineBraces :: [MultiplexedBrackets mpx] -> [ToPostProcess toPostProcess] {
    rightAhead = Lookahead(mpx[0], 1)
    bracketAhead = Lookahead(mpx[1], 1)
    leftRightMatch = rightAhead & ~mpx[0]
    typeMatch = ~(bracketAhead ^ mpx[1])
    matchedL = leftRightMatch & typeMatch
    advMatchedL = Advance(matchedL)
    matched = matchedL | advMatchedL
    toPostProcess[0] = ~matched
}

type StringSpan = <i1>[1]

kernel LexLocations :: [Lex lex] -> [BasisBits output] {
    rOrLCurly = lex.lCurly | lex.rCurly
    rOrLBracket = lex.lBracket | lex.rBracket
    colonOrQuote = lex.colon | lex.dQuote
    colonQuoteOrComma = colonOrQuote | lex.comma
    or = rOrLBracket | rOrLCurly
    or2 = or | colonQuoteOrComma
    number = lex.hyphen | lex.digit
    trueOrFalse = lex.t | lex.f
    tfOrNull = trueOrFalse | lex.n
    numberOrKeyword = number | tfOrNull
    or3 = or2 | numberOrKeyword
    wsOrBs = lex.ws | lex.backslash
    or4 = or3 | wsOrBs
    output[0] = or4
    output[1] = or4
    output[2] = or4
    output[3] = or4
    output[4] = or4
    output[5] = or4
    output[6] = or4
    output[7] = or4
}

kernel SpanLocations :: [StringSpan span] -> [BasisBits output] {
    s = span[0]
    output[0] = s
    output[1] = ~s
    output[2] = ~s
    output[3] = ~s
    output[4] = s
    output[5] = ~s
    output[6] = s
    output[7] = s
}
