/*
 *  Copyright (c) 2018 International Characters.
 *  This software is licensed to the public under the Open Software License 3.0.
 *  icgrep is a trademark of International Characters.
 */

#include <kernel/core/idisa_target.h>
#include <boost/filesystem.hpp>
#include <re/cc/cc_compiler.h>
#include <re/cc/cc_compiler_target.h>
#include <re/adt/adt.h>
#include <re/unicode/resolve_properties.h>
#include <unicode/utf/utf_compiler.h>
#include <kernel/core/kernel_builder.h>
#include <kernel/pipeline/pipeline_builder.h>
#include <kernel/basis/s2p_kernel.h>
#include <kernel/io/source_kernel.h>
#include <kernel/core/streamset.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/Module.h>
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/raw_ostream.h>
#include <kernel/pipeline/driver/cpudriver.h>
#include <toolchain/toolchain.h>
#include <pablo/pablo_toolchain.h>

#include <fileselect/file_select.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <iostream>

#include "simple_csv_schema_parser.hpp"
#include "csv_schema_validator.h"
#include "check_hash_table.h"
#include "csv_validator_toolchain.h"
#include "csv_matcher_engine.h"
#ifdef ENABLE_PAPI
#include <util/papi_helper.hpp>
#endif

namespace fs = boost::filesystem;

using namespace llvm;
using namespace codegen;

static cl::OptionCategory csvValidatorFlags("Command Flags", "CSV Validator options");


static cl::opt<std::string> inputSchema(cl::Positional, cl::desc("<input schema filename>"), cl::Required, cl::cat(csvValidatorFlags));

static cl::list<std::string> inputFiles(cl::Positional, cl::desc("<input file ...>"), cl::OneOrMore, cl::cat(csvValidatorFlags));

bool noHeaderLine = false;

static cl::opt<bool, true> optNoHeaderLine("no-header", cl::desc("CSV record data begins on first line"),
                                     cl::location(noHeaderLine), cl::init(false), cl::cat(csvValidatorFlags));

bool failFast = true;

static cl::opt<bool, true> optFailFast("fail-fast", cl::desc("Stops on the first validation error rather than reporting all errors"),
                                     cl::location(failFast), cl::init(true), cl::cat(csvValidatorFlags));

static cl::OptionCategory hashFlags("Hash Function Generation Flags", "CSV Validator options");

size_t NumOfSteps = 0;

static cl::opt<size_t, true> optNumOfSteps("steps", cl::location(NumOfSteps),  cl::init(4),
                                      cl::desc("number of steps used in the hashing function. Only the first 2^(STEPS) - 1 "
                                               "characters of each word will be represented in the hash code (default=4)"),
                                      cl::value_desc("positive integer"), cl::cat(hashFlags));

size_t NumOfHashBits = 0;

static cl::opt<size_t, true> optNumOfHashBits("hashsize", cl::location(NumOfHashBits), cl::init(30),
                                      cl::desc("number of hash bits generated by the hashing function (default=30)"),
                                      cl::value_desc("positive integer"), cl::cat(hashFlags));

size_t NumOfHashTrieLevels = 0;

static cl::opt<size_t, true> optNumOfHashTrieLevels("hashtrielevels" ,cl::location(NumOfHashTrieLevels),  cl::init(6),
                                      cl::desc("number of hash table trie levels (default=6)"),
                                      cl::value_desc("positive integer"), cl::cat(hashFlags));

size_t HashSeed = 0;

static cl::opt<size_t, true> optHashSeed("hashseed", cl::location(HashSeed),  cl::init(5381),
                                      cl::desc("seed used to generatd hash function (default=16)"),
                                      cl::value_desc("positive integer"), cl::cat(hashFlags));

size_t HashBitsPerTrie = 0;

std::vector<fs::path> allFiles;

void run(CSVValidatorFunctionType fn_ptr, const csv::CSVSchema & schema, const fs::path & fileName) {
    struct stat sb;
    const auto fn = fileName.c_str();
    const int fd = open(fn, O_RDONLY);
    if (LLVM_UNLIKELY(fd == -1)) {
        if (errno == EACCES) {
            std::cerr << "csv_validator: " << fileName << ": Permission denied.\n";
        }
        else if (errno == ENOENT) {
            std::cerr << "csv_validator: " << fileName << ": No such file.\n";
        }
        else {
            std::cerr << "csv_validator: " << fileName << ": Failed.\n";
        }
        return;
    }
    if (stat(fn, &sb) == 0 && S_ISDIR(sb.st_mode)) {
        std::cerr << "csv_validator: " << fileName << ": Is a directory.\n";
    } else {
        fn_ptr(fd, schema, fn);
    }
    close(fd);
}

int main(int argc, char *argv[]) {
    codegen::ParseCommandLineOptions(argc, argv, {&csvValidatorFlags, pablo::pablo_toolchain_flags(), codegen::codegen_flags()});
    if (argv::RecursiveFlag || argv::DereferenceRecursiveFlag) {
        argv::DirectoriesFlag = argv::Recurse;
    }

    if (NumOfHashTrieLevels < 1) {
        report_fatal_error("Trie levels must be positive");
    }

    HashBitsPerTrie = NumOfHashBits / NumOfHashTrieLevels;
    NumOfHashBits = HashBitsPerTrie * NumOfHashTrieLevels;

    CPUDriver pxDriver("csvv");

    allFiles = argv::getFullFileList(pxDriver, inputFiles);

    auto schema = csv::CSVSchemaParser::load(inputSchema);

    CSVMatcherEngine engine;

    auto funcPtr = engine.compile(pxDriver, schema);

    #ifdef REPORT_PAPI_TESTS
    papi::PapiCounter<4> jitExecution{{PAPI_L3_TCM, PAPI_L3_TCA, PAPI_TOT_INS, PAPI_TOT_CYC}};
    jitExecution.start();
    #endif

    for (auto & file : allFiles) {
        run(funcPtr, schema, file);
    }

    #ifdef REPORT_PAPI_TESTS
    jitExecution.stop();
    jitExecution.write(std::cerr);
    #endif

    return 0;
}
