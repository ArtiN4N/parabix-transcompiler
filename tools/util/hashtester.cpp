/*
 *  Copyright (c) 2019 International Characters.
 *  This software is licensed to the public under the Open Software License 3.0.
 *  icgrep is a trademark of International Characters.
 */

#include <kernel/streamutils/deletion.h>                      // for DeletionKernel
#include <kernel/io/source_kernel.h>
#include <kernel/basis/p2s_kernel.h>
#include <kernel/basis/s2p_kernel.h>                    // for S2PKernel
#include <kernel/io/stdout_kernel.h>                 // for StdOutKernel_
#include <kernel/streamutils/pdep_kernel.h>
#include <llvm/IR/Function.h>                      // for Function, Function...
#include <llvm/IR/Module.h>                        // for Module
#include <llvm/Support/CommandLine.h>              // for ParseCommandLineOp...
#include <llvm/Support/Debug.h>                    // for dbgs
#include <pablo/pablo_kernel.h>                    // for PabloKernel
#include <pablo/pablo_toolchain.h>
#include <pablo/parse/pablo_source_kernel.h>
#include <pablo/parse/pablo_parser.h>
#include <pablo/parse/simple_lexer.h>
#include <pablo/parse/rd_parser.h>
#include <re/adt/re_name.h>
#include <re/adt/re_re.h>
#include <grep/grep_kernel.h>
#include <re/cc/cc_compiler.h>
#include <re/cc/cc_compiler_target.h>
#include <re/unicode/resolve_properties.h>
#include <pablo/bixnum/bixnum.h>
#include <kernel/core/kernel_builder.h>
#include <pablo/pe_zeroes.h>
#include <toolchain/toolchain.h>
#include <kernel/pipeline/driver/cpudriver.h>
#include <kernel/core/streamset.h>
#include <kernel/scan/index_generator.h>
#include <kernel/scan/reader.h>
#include <kernel/streamutils/run_index.h>
#include <kernel/streamutils/stream_select.h>
#include <kernel/streamutils/streams_merge.h>
#include <kernel/util/bixhash.h>
#include <kernel/util/debug_display.h>
#include <llvm/ADT/StringRef.h>
#include <llvm/Support/raw_ostream.h>
#include <pablo/bixnum/bixnum.h>
#include <pablo/pe_zeroes.h>
#include <pablo/builder.hpp>
#include <pablo/pe_ones.h>
#include <unicode/utf/utf_compiler.h>
#include <re/unicode/resolve_properties.h>
#include <re/cc/cc_compiler.h>
#include <re/cc/cc_compiler_target.h>
#include <fcntl.h>
#include <iostream>
#include <iomanip>
#include <kernel/pipeline/pipeline_builder.h>
#include <boost/graph/adjacency_list.hpp>
#include <random>
#include <boost/filesystem.hpp>
#include <fileselect/file_select.h>
#include <boost/container/stable_vector.hpp>
#include "ga/algorithm.hpp"
#include <sys/stat.h>
#include <kernel/util/linebreak_kernel.h>

using namespace pablo;
using namespace parse;
using namespace kernel;
using namespace llvm;
using namespace codegen;
using namespace boost;
using namespace boost::graph;
namespace fs = boost::filesystem;

static cl::OptionCategory HashDemoOptions("Hash Demo Options", "Hash demo options.");

static cl::list<std::string> inputFiles(cl::Positional, cl::desc("<input file ...>"), cl::OneOrMore, cl::cat(HashDemoOptions));

constexpr static size_t NumOfBasisBits = 8;

static cl::opt<unsigned> NumOfBuckets("buckets",  cl::init(512),
                                      cl::desc("number of hash buckets used for chi-squared test (default=10000)"),
                                      cl::value_desc("positive integer"), cl::cat(HashDemoOptions));

static cl::opt<unsigned> NumOfSteps("steps",  cl::init(4),
                                      cl::desc("number of steps used in the hashing function. Only the first 2^(STEPS) - 1 "
                                               "characters of each word will be represented in the hash code (default=4)"),
                                      cl::value_desc("positive integer"), cl::cat(HashDemoOptions));

static cl::opt<unsigned> NumOfBitFlips("bitflips",  cl::init(64),
                                      cl::desc("number of bit flips generated for the hashing function data. "
                                               "Used to determine avalanche probability (default=64)"),
                                      cl::value_desc("positive integer"), cl::cat(HashDemoOptions));

static cl::opt<unsigned> NumOfHashBits("hashwidth",  cl::init(16),
                                      cl::desc("number of hash bits generated by the hashing function (default=16)"),
                                      cl::value_desc("positive integer"), cl::cat(HashDemoOptions));


class WordMarkKernel : public pablo::PabloKernel {
public:
    WordMarkKernel(BuilderRef kb, StreamSet * BasisBits, StreamSet * WordMarks);
protected:
    void generatePabloMethod() override;
};

WordMarkKernel::WordMarkKernel(BuilderRef kb, StreamSet * BasisBits, StreamSet * WordMarks)
: PabloKernel(kb, "WordMarks", {Binding{"source", BasisBits}}, {Binding{"WordMarks", WordMarks}}) { }

void WordMarkKernel::generatePabloMethod() {
    pablo::PabloBuilder pb(getEntryScope());
    re::RE * word_prop = re::makePropertyExpression("word");
    word_prop = UCD::linkAndResolve(word_prop);
    re::CC * word_CC = cast<re::CC>(cast<re::PropertyExpression>(word_prop)->getResolvedRE());
    Var * wordChar = pb.createVar("word");
    UTF::UTF_Compiler unicodeCompiler(getInputStreamVar("source"), pb);
    unicodeCompiler.addTarget(wordChar, word_CC);
    unicodeCompiler.compile();
    pb.createAssign(pb.createExtract(getOutputStreamVar("WordMarks"), pb.getInteger(0)), wordChar);
}

class ParseSymbols : public pablo::PabloKernel {
public:
    ParseSymbols(BuilderRef kb,
                StreamSet * basisBits, StreamSet * wordChar, StreamSet * symbolRuns)
    : pablo::PabloKernel(kb, "ParseSymbols",
                         {Binding{"basisBits", basisBits, FixedRate(1), LookAhead(1)},
                             Binding{"wordChar", wordChar, FixedRate(1), LookAhead(3)}},
                         {Binding{"symbolRuns", symbolRuns}}) { }
protected:
    void generatePabloMethod() override;
};

void ParseSymbols::generatePabloMethod() {
    pablo::PabloBuilder pb(getEntryScope());
    std::vector<PabloAST *> basis = getInputStreamSet("basisBits");
    cc::Parabix_CC_Compiler_Builder ccc(getEntryScope(), basis);
    pablo::PabloAST * wordChar = getInputStreamSet("wordChar")[0];
    // Find start bytes of word characters.
    PabloAST * ASCII = ccc.compileCC(re::makeCC(0x0, 0x7F));
    PabloAST * prefix2 = ccc.compileCC(re::makeCC(0xC2, 0xDF));
    PabloAST * prefix3 = ccc.compileCC(re::makeCC(0xE0, 0xEF));
    PabloAST * prefix4 = ccc.compileCC(re::makeCC(0xF0, 0xF4));
    PabloAST * wc1 = pb.createAnd(ASCII, wordChar);
    // Prefixes of word characters
    PabloAST * wprefix2 = pb.createAnd(prefix2, pb.createLookahead(wordChar, 1));
    PabloAST * wprefix3 = pb.createAnd(prefix3, pb.createLookahead(wordChar, 2));
    PabloAST * wprefix4 = pb.createAnd(prefix4, pb.createLookahead(wordChar, 3));
    wc1 = pb.createOr3(wc1, wprefix2, pb.createOr(wprefix3, wprefix4));
    //
    PabloAST * wordStart = pb.createAnd(pb.createNot(pb.createAdvance(wordChar, 1)), wc1, "wordStart");
    PabloAST * wordByte = pb.createOr(wc1, wordChar);
    // Interior bytes of 3 and 4 byte sequences.
    wordByte = pb.createOr(wordByte, pb.createAdvance(pb.createOr(wprefix3, wprefix4), 1));
    wordByte = pb.createOr(wordByte, pb.createAdvance(wprefix4, 2));
    // runs are the bytes after a start symbol until the next symStart byte.
    pablo::PabloAST * runs = pb.createInFile(pb.createAnd(pb.createNot(wordStart), wordByte));
    pb.createAssign(pb.createExtract(getOutputStreamVar("symbolRuns"), pb.getInteger(0)), runs);
}


class RunLengthSelector final: public pablo::PabloKernel {
public:
    RunLengthSelector(BuilderRef b,
                      unsigned lo,
                      unsigned hi,
                      StreamSet * symbolRun, StreamSet * const lengthBixNum,
                      StreamSet * overflow,
                      StreamSet * selected);
protected:
    void generatePabloMethod() override;
    unsigned mLo;
    unsigned mHi;
};

RunLengthSelector::RunLengthSelector(BuilderRef b,
                           unsigned lo,
                           unsigned hi,
                           StreamSet * symbolRun,
                           StreamSet * const lengthBixNum,
                           StreamSet * overflow,
                           StreamSet * selected)
: PabloKernel(b, "RunLengthSelector" + std::to_string(lengthBixNum->getNumElements()) + "x1:" + std::to_string(lo) + "-" + std::to_string(lo),
              {Binding{"symbolRun", symbolRun, FixedRate(), LookAhead(1)},
                  Binding{"lengthBixNum", lengthBixNum},
                  Binding{"overflow", overflow}},
              {Binding{"selected", selected}}), mLo(lo), mHi(hi) { }

void RunLengthSelector::generatePabloMethod() {
    PabloBuilder pb(getEntryScope());
    BixNumCompiler bnc(pb);
    PabloAST * run = getInputStreamSet("symbolRun")[0];
    std::vector<PabloAST *> lengthBixNum = getInputStreamSet("lengthBixNum");
    PabloAST * overflow = getInputStreamSet("overflow")[0];
    PabloAST * runFinal = pb.createAnd(run, pb.createNot(pb.createLookahead(run, 1)));
    runFinal = pb.createAnd(runFinal, pb.createNot(overflow));
    Var * groupStreamVar = getOutputStreamVar("selected");
    // Run index codes count from 0 on the 2nd byte of a symbol.
    // So the length is 2 more than the bixnum.
    unsigned offset = 2;
    PabloAST * groupStream = pb.createAnd3(bnc.UGE(lengthBixNum, mLo - offset), bnc.ULE(lengthBixNum, mHi - offset), runFinal);
    pb.createAssign(pb.createExtract(groupStreamVar, pb.getInteger(0)), groupStream);
}

class IdentifyLastSelector final: public pablo::PabloKernel {
public:
    IdentifyLastSelector(BuilderRef b, StreamSet * selector_span, StreamSet * selectors)
    : PabloKernel(b, "IdentifyLastSelector",
                  {Binding{"selector_span", selector_span, FixedRate(), LookAhead(1)}},
                  {Binding{"selectors", selectors}}) {}
protected:
    void generatePabloMethod() override;
};


void IdentifyLastSelector::generatePabloMethod() {
    PabloBuilder pb(getEntryScope());
    // TODO: we shouldn't need this kernel to obtain the last mark of each run of a selector_span
    // if we can push them ahead to the end of the run but that may add an N advances where N is
    // the hash code bit width.
    pablo::Integer * pb_ZERO = pb.getInteger(0);
    PabloAST * span = pb.createExtract(getInputStreamVar("selector_span"), pb_ZERO);
    PabloAST * la = pb.createLookahead(span, 1);
    PabloAST * selectors = pb.createAnd(span, pb.createNot(la));
    pb.createAssign(pb.createExtract(getOutputStreamVar("selectors"), pb_ZERO), selectors);
}

using BixHashGraphGenome = adjacency_list<vecS, vecS, bidirectionalS>;

class BixHashGenerator final: public pablo::PabloKernel {
    static std::string makeGenName(const BixHashGraphGenome & genome) {
        std::string tmp;
        tmp.reserve(1024);
        raw_string_ostream out(tmp);
        out << "BHG:" << NumOfSteps << ":" << NumOfHashBits;
        for (auto e : make_iterator_range(edges(genome))) {
            out << ":" << source(e, genome) << "," << target(e, genome);
        }
        out.flush();
        return tmp;
    }
public:
    BixHashGenerator(BuilderRef b, const BixHashGraphGenome & genome, StreamSet * basis, StreamSet * run, StreamSet * hashes, StreamSet * selector_span)
    : BixHashGenerator(b, genome, makeGenName(genome), basis, run, hashes, selector_span) {

    }
    bool hasSignature() const override { return true; }
    llvm::StringRef getSignature() const override {
        return mSiganture;
    }
private:
    BixHashGenerator(BuilderRef b, const BixHashGraphGenome & genome, std::string && signature, StreamSet * basis, StreamSet * run, StreamSet * hashes, StreamSet * selector_span)
    : PabloKernel(b, "bhg" + getStringHash(signature),
                  {Binding{"basis", basis}, Binding{"run", run}},
                  {Binding{"hashes", hashes}, Binding{"selector_span", selector_span}})
    , mGenome(genome) {
        assert (hashes->getNumElements() == NumOfHashBits);
        assert (selector_span->getNumElements() == 1);
    }
protected:
    void generatePabloMethod() override;
private:
    const BixHashGraphGenome & mGenome;
    const std::string mSiganture;
};

void BixHashGenerator::generatePabloMethod() {
    PabloBuilder pb(getEntryScope());

    // TODO: if we assume this version of a BixHash is designed for UTF-8 text, are there optimal mixes?
    // Can we use a genetic algorithm to deduce it?

    std::vector<PabloAST *> basis = getInputStreamSet("basis");
    const size_t n = NumOfBasisBits; assert (n == basis.size());
    PabloAST * run = getInputStreamSet("run")[0];
    const size_t m = NumOfHashBits;
    const size_t steps = NumOfSteps;

    std::vector<PabloAST *> hash(n + m * (steps + 1));

    // Let N be the number of basis bits (8), M be the number of hash bits and K be the number of steps.
    // The mHashMix starts with a set of N and a set of M vertices, denoted A and B. Edges are strictly
    // between vertices in A and B represent xor operations of the basis bits from A.

    SmallVector<PabloAST *, NumOfBasisBits> xors;

    for (unsigned i = 0; i < n; ++i) {
        hash[i] = basis[i];
    }

    for (unsigned i = 0; i < m; ++i) {
        for (const auto e : make_iterator_range(in_edges(i + NumOfBasisBits, mGenome))) {
            const auto j = source(e, mGenome);
            assert (hash[j]);
            xors.push_back(hash[j]);
        }
        const auto m = xors.size();
        PabloAST * out = nullptr;
        if (m == 0) {
            out = pb.createZeroes();
        } else {
            for (unsigned j = 1; j < m; ++j) {
                xors[0] = pb.createXor(xors[0], xors[j]);
            }
            out = pb.createAnd(xors[0], run);
            xors.clear();
        }
        assert (out);
        hash[i + n] = out;
    }

    // In each step, the select stream will mark positions that are
    // to receive bits from prior locations in the symbol.   The
    // select stream must ensure that no bits from outside the symbol
    // are included in the calculated hash value.
    PabloAST * select = run;


    for (unsigned i = 0; i < steps; ++i) {

        const auto shft = 1U << i;
        const auto s = n + m * (i + 1);

        for (unsigned j = 0; j < m; j++) {
            PabloAST * h = hash[s + j - m]; assert (h);
            if (in_degree(s + j, mGenome) > 0) {
                h = pb.createAnd(pb.createAdvance(h, shft), select);
                for (const auto e : make_iterator_range(in_edges(s + j, mGenome))) {
                    const auto k = source(e, mGenome);
                    assert (k < s + j);
                    assert (hash[k]);
                    h = pb.createXor(h, hash[k]);
                }
            }
            hash[s + j] = h;
        }

        select = pb.createAnd(select, pb.createAdvance(select, shft));
    }


    Var * hashVar = getOutputStreamVar("hashes");
    for (unsigned i = 0; i < m; i++) {
        PabloAST * const expr = hash[n + (steps * m) + i]; assert (expr);
        pb.createAssign(pb.createExtract(hashVar, pb.getInteger(i)), expr);
    }

    // if the value is still in the select span, we did not include it in the hash'ed value.
    PabloAST * const selectors = pb.createAnd(run, pb.createNot(select), "selectors");
    pb.createAssign(pb.createExtract(getOutputStreamVar("selector_span"), pb.getInteger(0)), selectors);

}

class HashTable {
public:

    HashTable()
    : mTable(NumOfBuckets)
    , mTotalCount(0)
    , mInvBinSize((double)(NumOfBuckets) / (double)(1UL << NumOfHashBits)) {

    }

    void insert(const uint64_t hash_code, const char * const start, const char * const end) {
        const uint64_t idx = hash_code * mInvBinSize;
        auto & T = mTable[idx];
        const auto l = end - start + 1;
        StringRef S(start, l);
        auto f = T.find(S);
        if (f == T.end()) {
            char * const newArray = mAllocator.allocate(l);
            std::memcpy(newArray, start, l);
            StringRef N(newArray, l);
            T.insert(N);
            ++mTotalCount;
        }
    }

    void clear() {
        for (auto & T : mTable) {
            T.clear();
        }
        mTotalCount = 0;
        mAllocator.Reset();
    }

    double chiSquareTest() const {
        assert (mTotalCount > 0);
        const double expected = (double)(mTotalCount) / (double)(mTable.size());
        double sum = 0.0;
        for (const auto & T : mTable) {
            const auto x = (double)(T.size()) - expected;
            sum += x * x;
        }
        return sum / expected;
    }

private:
    std::vector<DenseSet<StringRef>>    mTable;
    size_t                              mTotalCount;

    const double                        mInvBinSize;
    SlabAllocator<char>                 mAllocator;
};


static HashTable HT;

typedef void (*HashDemoFunctionType)(const char * data, const size_t length);

extern "C" void hashtable_callback(uint64_t hashval, const char * const start, const char * const end) {
    HT.insert(hashval, start, end);
}

class PopulateHashTable : public MultiBlockKernel {
public:
    PopulateHashTable(BuilderRef b, StreamSet * const codeUnitStream, StreamSet * const SymbolEnds, StreamSet * const HashValues);

    void linkExternalMethods(BuilderRef b) override;
private:
    void generateMultiBlockLogic(BuilderRef b, llvm::Value * const numOfStrides) override;
};

PopulateHashTable::PopulateHashTable(BuilderRef b, StreamSet * const codeUnitStream, StreamSet * const SymbolEnds, StreamSet * const HashValues)
: MultiBlockKernel(b, "PopulateHashTable",
// inputs
{Binding{"codeUnitStream", codeUnitStream, FixedRate(), Deferred()} // <- not the right I/O def. should be the position of the symbol ends
, Binding{"SymbolEnds", SymbolEnds}
, Binding{"HashValues", HashValues, PopcountOf("SymbolEnds")}},
// outputs
{},
// input scalars
{},
// output scalars
{},
// kernel state
{}) {
     assert (SymbolEnds->getNumElements() == 1);
     assert (HashValues->getNumElements() == 1);
     assert (codeUnitStream->getNumElements() == 1);
     addAttribute(SideEffecting());
}

void PopulateHashTable::linkExternalMethods(BuilderRef b) {
    b->LinkFunction("hashtable_callback", hashtable_callback);
}

void PopulateHashTable::generateMultiBlockLogic(BuilderRef b, llvm::Value * const numOfStrides) {

    Constant * const sz_ZERO = b->getSize(0);
    Constant * const sz_ONE = b->getSize(1);
    IntegerType * sizeTy = b->getSizeTy();
    const auto sizeTyWidth = sizeTy->getBitWidth();

    Constant * const sz_BITS = b->getSize(sizeTyWidth);

    Constant * const sz_STRIDEWIDTH = b->getSize(mStride);

    assert (mStride == b->getBitBlockWidth());

    assert ((mStride % sizeTyWidth ) == 0);

    const auto vecsPerStride = mStride / sizeTyWidth;

    BasicBlock * const entryBlock = b->GetInsertBlock();

    // we expect that every block will have at least one marker

    BasicBlock * const stridePrologue = b->CreateBasicBlock("stridePrologue");
    BasicBlock * const strideCoordinateVecLoop = b->CreateBasicBlock("strideCoordinateVecLoop");
    BasicBlock * const strideCoordinateElemLoop = b->CreateBasicBlock("strideCoordinateElemLoop");
    BasicBlock * const strideCoordinateElemDone = b->CreateBasicBlock("strideCoordinateElemDone");
    BasicBlock * const strideCoordinateVecDone = b->CreateBasicBlock("strideCoordinateVecDone");
    BasicBlock * const strideCoordinatesDone = b->CreateBasicBlock("strideCoordinatesDone");

    Value * const initialProcessed = b->getProcessedItemCount("codeUnitStream");

    Value * const initialStrideCount = b->CreateUDiv(b->getProcessedItemCount("SymbolEnds"), sz_STRIDEWIDTH);

    Value * const hashProcessed = b->getProcessedItemCount("HashValues");

    b->CreateBr(stridePrologue);

    b->SetInsertPoint(stridePrologue);
    PHINode * const strideNumPhi = b->CreatePHI(sizeTy, 2);
    strideNumPhi->addIncoming(sz_ZERO, entryBlock);
    PHINode * const outerProcessedPhi = b->CreatePHI(sizeTy, 2);
    outerProcessedPhi->addIncoming(initialProcessed, entryBlock);
    PHINode * const outerHashProcessedPhi = b->CreatePHI(sizeTy, 2);
    outerHashProcessedPhi->addIncoming(hashProcessed, entryBlock);

    Value * const symbolEnds = b->loadInputStreamBlock("SymbolEnds", sz_ZERO, strideNumPhi);
    Value * const strideBaseCharacterOffset = b->CreateMul(b->CreateAdd(initialStrideCount, strideNumPhi), sz_STRIDEWIDTH);

    FixedVectorType * const sizeVecTy = FixedVectorType::get(sizeTy, vecsPerStride);
    Value * const symbolEndVec = b->CreateBitCast(symbolEnds, sizeVecTy);

    b->CreateLikelyCondBr(b->bitblock_any(symbolEnds), strideCoordinateVecLoop, strideCoordinateVecDone);

    b->SetInsertPoint(strideCoordinateVecLoop);
    PHINode * const elemIdx = b->CreatePHI(sizeTy, 2, "elemIdx");
    elemIdx->addIncoming(sz_ZERO, stridePrologue);
    PHINode * const incomingProcessedPhi = b->CreatePHI(sizeTy, 2);
    incomingProcessedPhi->addIncoming(outerProcessedPhi, stridePrologue);
    PHINode * const incomingHashProcessedPhi = b->CreatePHI(sizeTy, 2);
    incomingHashProcessedPhi->addIncoming(outerHashProcessedPhi, stridePrologue);

    Value * const elem = b->CreateExtractElement(symbolEndVec, elemIdx);
    b->CreateCondBr(b->CreateICmpNE(elem, sz_ZERO), strideCoordinateElemLoop, strideCoordinateElemDone);

    b->SetInsertPoint(strideCoordinateElemLoop);
    PHINode * const remaining = b->CreatePHI(sizeTy, 2);
    remaining->addIncoming(elem, strideCoordinateVecLoop);
    PHINode * const innerProcessedPhi = b->CreatePHI(sizeTy, 2);
    innerProcessedPhi->addIncoming(incomingProcessedPhi, strideCoordinateVecLoop);
    PHINode * const innerHashProcessedPhi = b->CreatePHI(sizeTy, 2);
    innerHashProcessedPhi->addIncoming(incomingHashProcessedPhi, strideCoordinateVecLoop);

    Value * pos = b->CreateCountForwardZeroes(remaining);
    pos = b->CreateAdd(pos, b->CreateMul(elemIdx, sz_BITS));
    pos = b->CreateAdd(pos, strideBaseCharacterOffset);

    FixedArray<Value *, 3> args;
    Value * const hashPtr = b->getRawInputPointer("HashValues", innerHashProcessedPhi);

    args[0] = b->CreateZExt(b->CreateLoad(hashPtr), sizeTy);
    args[1] = b->getRawInputPointer("codeUnitStream", innerProcessedPhi);
    args[2] = b->getRawInputPointer("codeUnitStream", pos);

    Function * callbackFn = b->getModule()->getFunction("hashtable_callback"); assert (callbackFn);
    b->CreateCall(callbackFn->getFunctionType(), callbackFn, args);

    Value * const nextRemaining = b->CreateResetLowestBit(remaining);

    remaining->addIncoming(nextRemaining, strideCoordinateElemLoop);

    Value * const nextHashProcessed = b->CreateAdd(innerHashProcessedPhi, sz_ONE);

    innerHashProcessedPhi->addIncoming(nextHashProcessed, strideCoordinateElemLoop);
    innerProcessedPhi->addIncoming(pos, strideCoordinateElemLoop);

    b->CreateCondBr(b->CreateICmpNE(nextRemaining, sz_ZERO), strideCoordinateElemLoop, strideCoordinateElemDone);

    b->SetInsertPoint(strideCoordinateElemDone);

    PHINode * const nextProcessedPhi = b->CreatePHI(sizeTy, 2);
    nextProcessedPhi->addIncoming(incomingProcessedPhi, strideCoordinateVecLoop);
    nextProcessedPhi->addIncoming(pos, strideCoordinateElemLoop);
    incomingProcessedPhi->addIncoming(nextProcessedPhi, strideCoordinateElemDone);

    PHINode * const nextHashProcessedPhi = b->CreatePHI(sizeTy, 2);
    nextHashProcessedPhi->addIncoming(outerHashProcessedPhi, strideCoordinateVecLoop);
    nextHashProcessedPhi->addIncoming(nextHashProcessed, strideCoordinateElemLoop);
    incomingHashProcessedPhi->addIncoming(nextHashProcessedPhi, strideCoordinateElemDone);

    Value * const nextElemIdx = b->CreateAdd(elemIdx, sz_ONE);
    elemIdx->addIncoming(nextElemIdx, strideCoordinateElemDone);
    Value * const moreVecs = b->CreateICmpNE(nextElemIdx, b->getSize(vecsPerStride));
    b->CreateCondBr(moreVecs, strideCoordinateVecLoop, strideCoordinateVecDone);

    b->SetInsertPoint(strideCoordinateVecDone);
    PHINode * const nextOuterProcessedPhi = b->CreatePHI(sizeTy, 2);
    nextOuterProcessedPhi->addIncoming(nextProcessedPhi, strideCoordinateElemDone);
    nextOuterProcessedPhi->addIncoming(outerProcessedPhi, stridePrologue);
    outerProcessedPhi->addIncoming(nextOuterProcessedPhi, strideCoordinateVecDone);

    PHINode * const nextOuterHashProcessedPhi = b->CreatePHI(sizeTy, 2);
    nextOuterHashProcessedPhi->addIncoming(nextHashProcessedPhi, strideCoordinateElemDone);
    nextOuterHashProcessedPhi->addIncoming(outerHashProcessedPhi, stridePrologue);
    outerHashProcessedPhi->addIncoming(nextOuterHashProcessedPhi, strideCoordinateVecDone);

    Value * const nextStrideNum = b->CreateAdd(strideNumPhi, sz_ONE);
    strideNumPhi->addIncoming(nextStrideNum, strideCoordinateVecDone);

    b->CreateCondBr(b->CreateICmpULT(nextStrideNum, numOfStrides), stridePrologue, strideCoordinatesDone);

    b->SetInsertPoint(strideCoordinatesDone);
    b->setProcessedItemCount("codeUnitStream", nextOuterProcessedPhi);
}


HashDemoFunctionType hashdemo_gen (CPUDriver & driver, const BixHashGraphGenome & genome) {

    auto & b = driver.getBuilder();
    auto P = driver.makePipeline({Binding{b->getInt8PtrTy(), "input"}, Binding{b->getSizeTy(), "length"}}, {});

    std::string tmp;
    raw_string_ostream nm(tmp);
    nm << "hashtester" << NumOfBasisBits << ":" << NumOfHashBits << "x" << NumOfSteps;
    P->setUniqueName(nm.str());

    Scalar * input = P->getInputScalar("input");
    Scalar * length = P->getInputScalar("length");

    // Source data
    StreamSet * const codeUnitStream = P->CreateStreamSet(1, NumOfBasisBits);
    P->CreateKernelCall<MemorySourceKernel>(input, length, codeUnitStream);

    StreamSet * const u8basis = P->CreateStreamSet(NumOfBasisBits);
    P->CreateKernelCall<S2PKernel>(codeUnitStream, u8basis);

    StreamSet * LineFeeds = P->CreateStreamSet(1);
    P->CreateKernelCall<LineFeedKernelBuilder>(u8basis, LineFeeds);

    StreamSet * const SymbolRuns = P->CreateStreamSet(1);
    P->CreateKernelCall<ParseSymbols>(u8basis, LineFeeds, SymbolRuns);

    StreamSet * const runIndex = P->CreateStreamSet(4);
    StreamSet * const overflow = P->CreateStreamSet(1);
    P->CreateKernelCall<RunIndex>(SymbolRuns, runIndex, overflow);

    StreamSet * const BixHashes = P->CreateStreamSet(NumOfHashBits);
    StreamSet * SelectorSpans = P->CreateStreamSet(1);
    P->CreateKernelFamilyCall<BixHashGenerator>(genome, u8basis, SymbolRuns, BixHashes, SelectorSpans);

    StreamSet * SymbolEnds = P->CreateStreamSet(1);
    P->CreateKernelCall<IdentifyLastSelector>(SelectorSpans, SymbolEnds);

    StreamSet * const Hashes = P->CreateStreamSet(NumOfHashBits);
    FilterByMask(P, SymbolEnds, BixHashes, Hashes);

    StreamSet * const HashValues = P->CreateStreamSet(1, NumOfHashBits);

    if (NumOfHashBits <= 8) {
        P->CreateKernelCall<P2SKernel>(Hashes, HashValues);
    } else if (NumOfHashBits <= 16) {
        P->CreateKernelCall<P2S16Kernel>(Hashes, HashValues);
    } else {
        // TODO: make 32 bit version
        report_fatal_error("Only supports up to 16 hash bits");
    }

    P->CreateKernelCall<PopulateHashTable>(codeUnitStream, SymbolEnds, HashValues);

    auto f = reinterpret_cast<HashDemoFunctionType>(P->compile());
    assert (f);
    return f;
}

class bixhash_optimization_problem {
public:
    using individual_type = std::shared_ptr<BixHashGraphGenome>;
    using generator_type = std::mt19937;
    using fitness_type = double;


    constexpr static double recombination_rate = 0.4;

    constexpr static double mutation_rate = 0.02;

    auto evaluate(const individual_type & x, generator_type&) const -> fitness_type {
        CPUDriver pxDriver("hashtester");
        auto func = hashdemo_gen(pxDriver, *x);
        func(InputData.data(), InputData.size());
        const auto r = HT.chiSquareTest();
        HT.clear();
        return r;
    }

    auto recombine(const individual_type & x, const individual_type & y,
                  generator_type& g) const -> std::array<individual_type, 2u> {

        if (!ga::draw(recombination_rate, g)) {
            return std::array<individual_type, 2u> {x, y};
        }

        const auto size = NumOfBasisBits + NumOfHashBits * (NumOfSteps + 1);

        const BixHashGraphGenome & A = *x;
        const BixHashGraphGenome & B = *y;

        BixHashGraphGenome::edge_iterator ea, ea_end;
        std::tie(ea, ea_end) = edges(A);
        BixHashGraphGenome::edge_iterator eb, eb_end;
        std::tie(eb, eb_end) = edges(B);

        const auto m = std::min(num_edges(A), num_edges(B));

        std::uniform_int_distribution<size_t> pos(1, m - 2);

        const auto p = pos(g);

        auto C = std::make_shared<BixHashGraphGenome>(size);
        auto D = std::make_shared<BixHashGraphGenome>(size);

        for (size_t i = 0; i < p; ++i) {
            assert (ea != ea_end);
            add_edge(source(*ea, A), target(*ea, A), *C);
            ++ea;
            assert (eb != eb_end);
            add_edge(source(*eb, B), target(*eb, B), *D);
            ++eb;
        }

        for (; ea != ea_end; ++ea) {
            const auto s = source(*ea, A);
            const auto t = target(*ea, A);
            if (!edge(s, t, *D).second) {
                add_edge(s, t, *D);
            }
        }

        for (; eb != eb_end; ++eb) {
            const auto s = source(*eb, B);
            const auto t = target(*eb, B);
            if (!edge(s, t, *C).second) {
                add_edge(s, t, *C);
            }
        }

        clean_genome(*D);

        clean_genome(*C);

        return std::array<individual_type, 2u> {std::move(C), std::move(D)};
    }

    auto mutate(individual_type & x, generator_type& g) const -> void {

        // we want to flip one of the edge/non-edges

        BixHashGraphGenome & C = *x;

        const auto n = num_vertices(C);
        assert (n == (NumOfBasisBits + NumOfHashBits * (NumOfSteps + 1)));

        std::uniform_int_distribution<size_t> U(NumOfBasisBits, n - 2);
        const auto u = U(g);
        std::uniform_int_distribution<size_t> V(u + 1, n - 1);
        const auto v = V(g);
        assert (u >= NumOfBasisBits);
        assert (u < v);

        if (edge(u, v, C).second) {
            remove_edge(u, v, C);
        } else {
            add_edge(u, v, C);
        }

        clean_genome(C);
    }

    static std::vector<individual_type> generate(const size_t count, generator_type & rng) {

        constexpr size_t n = NumOfBasisBits;
        const size_t m = NumOfHashBits;
        const size_t steps = NumOfSteps;

        const auto size = n + m * (steps + 1);

        constexpr double stddev = 0.7;
        constexpr double M = 0.5; // 1.0
        constexpr double sqrt_2_pi = 2.5066282746310005024157652848110452530069867406099383166299235763;

        std::vector<individual_type> P;
        P.reserve(count);

        for (unsigned p = 0; p < count; ++p) {

            std::uniform_real_distribution<double> X(0, 1.0);

            const auto x = X(rng);

            assert (0.0 <= x && x <= 1.0);

            const auto d = ((x - 0.5) / (2 * stddev * stddev));
            const auto e = std::exp((d * d) / -(2 * stddev * stddev));
            const auto f = (M / (stddev * sqrt_2_pi)) * e;

            assert (0.0 <= f && f <= 1.0);

            auto k = (size_t)std::round(f * size);

            auto C = std::make_shared<BixHashGraphGenome>(size);

            for (unsigned i = 0; i < k; ++i) {
                std::uniform_int_distribution<size_t> U(NumOfBasisBits, size - 2);
                const auto u = U(rng);
                std::uniform_int_distribution<size_t> V(u + 1, size - 1);
                const auto v = V(rng);
                assert (u >= NumOfBasisBits);
                assert (u < v);
                add_edge(u, v, *C);
            }

            clean_genome(*C);

            P.emplace_back(std::move(C));
        }

        assert (P.size() == count);

        return P;
    }

    static void clean_genome(BixHashGraphGenome & G) {
        // We have N basis bits and STEPS * (M + 1) other verticies. Each layer of M vertices defines what will eventually
        // be written. If a layer is not the last, it must have an out degree of at least one or it will simply generate
        // dead code.

        const auto limit = NumOfBasisBits + NumOfSteps * (NumOfHashBits + 1);
        for (unsigned i = limit; i > NumOfBasisBits; --i) {
            if (out_degree(i, G) == 0) {
                clear_in_edges(i, G);
            }
        }
    }

    bixhash_optimization_problem(const std::vector<fs::path> & fileNames, generator_type & rng)
    : InputData(readFileData(fileNames, rng)) {

    }

    static std::vector<char> readFileData(const std::vector<fs::path> & fileNames, generator_type & rng) {
        std::vector<char> data;

        char * line = nullptr;
        size_t len = 0;
        const ssize_t maxLineSize = 1UL << NumOfSteps;

        BitVector T(maxLineSize * 8);

        for (const fs::path & fileName: fileNames) {

            FILE * const fp = fopen(fileName.c_str(), "r");
            if (LLVM_UNLIKELY(fp == nullptr)) {
                report_fatal_error("Error: cannot open " + fileName.string() + ".");
            }


            struct stat st;
            if (LLVM_LIKELY(stat(fileName.c_str(), &st) == 0)) {
                data.reserve(st.st_size);
            }

            for (;;) {
                const auto r = getline(&line, &len, fp);
                // r is -1 or the number of characters read, including the delimiter
                if (LLVM_UNLIKELY(r == -1)) {
                    break;
                }
                if (LLVM_UNLIKELY(r == 0)) {
                    continue;
                }
                const auto m = std::min<ssize_t>(r, maxLineSize);

                const auto s = data.size();

                const auto t = std::min<unsigned>(NumOfBitFlips, (m * 8));

                data.resize(s + (m + 1) * (t + 1));

                std::memcpy(&data[s], line, m);

                auto p = s + m;

                data[p++] = '\n';

                T.reset();

                // generate bit flipped data from the original "word"
                for (unsigned i = 0; i < t; ++i) {

                    std::memcpy(&data[p], line, m);


                    assert (!T.all());

                    assert (i <= (m * 8) - 1);

                    std::uniform_int_distribution<size_t> pos(0, (m * 8) - 1 - i);

                    const auto j = pos(rng);

                    for (auto k = T.find_next_unset(j); k != -1; k = T.find_next_unset(k)) {

                        char & c = data[p + (k / 8)];

                        c ^= (1U << (k & 7));

                        T.set(k);
                    }

                    p += m;

                    data[p++] = '\n';
                }

                assert (data.size() == p);
            }
            fclose(fp);
        }
        return data;
    }


private:

    const std::vector<char> InputData;

};


/** ------------------------------------------------------------------------------------------------------------- *
 * @brief printGraph
 ** ------------------------------------------------------------------------------------------------------------- */
template <typename Graph>
void printGraph(const Graph & G, raw_ostream & out, const StringRef name = "G") {

    out << "digraph \"" << name << "\" {\n";
    for (auto v : make_iterator_range(vertices(G))) {
        out << "v" << v << " [label=\"" << v << "\"];\n";
    }
    for (auto e : make_iterator_range(edges(G))) {
        const auto s = source(e, G);
        const auto t = target(e, G);
        out << "v" << s << " -> v" << t << ";\n";
    }

    out << "}\n\n";
    out.flush();
}


int main(int argc, char *argv[]) {
    codegen::ParseCommandLineOptions(argc, argv, {&HashDemoOptions, pablo_toolchain_flags(), codegen::codegen_flags()});

    CPUDriver pxDriver("hashtester");
    auto allFiles = argv::getFullFileList(pxDriver, inputFiles);

    bixhash_optimization_problem::generator_type generator;

    bixhash_optimization_problem P(allFiles, generator);

    std::size_t elite_count = 2;
    const unsigned generation_count = 50;
    const unsigned population_count = 10;

    errs() << "INIT POP:\n";

    auto initial_population = bixhash_optimization_problem::generate(population_count, generator);

    errs() << "INIT ALGO:\n";

    ga::algorithm<bixhash_optimization_problem> algorithm(std::move(P), std::move(initial_population), elite_count, std::move(generator));

    // ===== Iterate the algorithm ===== //

    for (unsigned i = 0u; i < generation_count; ++i) {
        errs() << "ROUND: " << i << "\n";
        algorithm.iterate();
    }
    // ===== Retrieve solution information ===== //

    // Every candidate solution in the population sorted by fitness.
    const auto & solution = algorithm.population().front();

    printGraph(*(solution.x), errs(), "SOLUTION");
    errs() << "\n\nFITNESS: " << solution.fitness << "\n";

    return 0;
}
